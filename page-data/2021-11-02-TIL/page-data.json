{"componentChunkName":"component---src-templates-blog-template-js","path":"/2021-11-02-TIL/","result":{"data":{"cur":{"id":"161cd400-0d8a-5b98-9155-44a8e78e9392","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECA//EABUBAQEAAAAAAAAAAAAAAAAAAAAF/9oADAMBAAIQAxAAAAHSaSawD//EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIU/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CIv8A/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERIDH/2gAIAQEAAT8hGb2Ff//aAAwDAQACAAMAAAAQHD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAACAwEAAAAAAAAAAAAAAAABEQAgQVH/2gAIAQEAAT8QjVhju1//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"github-blog.png\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/TIL.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/TIL.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/TIL.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/TIL.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<hr>\n<br>\n<h3 id=\"1-docker\" style=\"position:relative;\"><a href=\"#1-docker\" aria-label=\"1 docker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Docker</h3>\n<hr>\n<ul>\n<li>도커(Docker)는 쉽게 애플리케이션을 추상화 하고, 컨테이너 방식으로 실행할 수 있게 해주는 리눅스 컨테이너기반의 오픈소스 가상화 플랫폼중 가장 대표적인 종류 중 하나이다</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-1-리눅스-컨테이너\" style=\"position:relative;\"><a href=\"#1-1-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88\" aria-label=\"1 1 리눅스 컨테이너 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 리눅스 컨테이너</h4>\n<hr>\n<center><img src=\"https://user-images.githubusercontent.com/83164003/139808345-7b0f1906-f1f1-4b49-a936-ab22be21dc37.png\"></center><br>\n<ul>\n<li>\n<p>개발자들은 개별적인 로컬 환경에서 작업하며 특정하게 설정된 환경을 사용하고 있으며, 현재 개발 중인 애플리케이션은 특정 라이브러리, 종속성 및 파일에 의존하고 있다.</p>\n<p>이러한 애플리케이션을 배포할때 임의의 환경에서도 애플리케이션이 작동되게 하고, 품질 검사를 통과하고, 큰 문제나 수정 없이 애플리케이션을 배포하려면 <strong>리눅스 컨테이너(LXC)</strong> 를 사용해야 한다.</p>\n</li>\n<li>\n<p>컨테이너는 다음 세가지의 자원을 독립적으로 격리하며 소유하고 있다.</p>\n<ul>\n<li>\n<p>프로세스</p>\n<ul>\n<li>\n<p>특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스할 수 있다.</p>\n</li>\n<li>\n<p>컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향을 줄 수 없다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>네트워크</p>\n<ul>\n<li>기본으로 컨테이너 하나에 하나의 IP 주소가 할당되어 있다.</li>\n</ul>\n</li>\n<li>\n<p>파일 시스템</p>\n<ul>\n<li>컨테이너 안에서 사용되는 파일 시스템은 구획화되어 있다. 그래서 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>요약하자면, 리눅스 컨테이너란 애플리케이션이 의존성, 네트워크 환경, 파일 시스템에 구애받지 않고 실행될 수 있도록 만든 애플리케이션 상자이다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-2-이미지\" style=\"position:relative;\"><a href=\"#1-2-%EC%9D%B4%EB%AF%B8%EC%A7%80\" aria-label=\"1 2 이미지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. 이미지</h4>\n<hr>\n<ul>\n<li>\n<p>실행되는 모든 컨테이너는 이미지로부터 생성된다.</p>\n</li>\n<li>\n<p>이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있으며, 상태값을 가지지 않고 변하지 않는다(Immutable).</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-3-docker-cli\" style=\"position:relative;\"><a href=\"#1-3-docker-cli\" aria-label=\"1 3 docker cli permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-3. Docker CLI</h4>\n<hr>\n<ul>\n<li>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/container_run/\" target=\"_blank\">공식문서</a>를 통해 Docker Image 및 Container를 다루는 방법을 학습하였다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">danielkraic</code>이 올린 이미지 <code class=\"language-text\">asciiquarium</code> 예시.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">docker container run <span class=\"token operator\">-</span>it <span class=\"token operator\">--</span>rm danielkraic<span class=\"token operator\">/</span>asciiquarium<span class=\"token operator\">:</span>latest</code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/139811648-6f3d6411-5c3a-4a28-96a5-608917578ec4.gif\" alt=\"ezgif-2-d2c8d5e087b7\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h3 id=\"2-컨테이너와-vm의-비교\" style=\"position:relative;\"><a href=\"#2-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-vm%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"2 컨테이너와 vm의 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 컨테이너와 VM의 비교</h3>\n<hr>\n<ul>\n<li>\n<p>컨테이너 기술과 가상 머신(VM)은 둘 다 프로세스, 네트워크, 파일 시스템을 격리할 수 있다는 장점을 공유하지만, 이 둘의 작동원리는 많이 다르다.</p>\n<p>VM(가상머신 <code class=\"language-text\">ex.에뮬레이터</code>)을 만들고 실행하는 과정이 많은 컴퓨팅 자원을 필요로 하지만, 도커는 한 호스트 컴퓨터에 여러 개의 컨테이너를 띄워도 크게 컴퓨터에 무리가 가지 않는 장점이 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/139812480-0a9ca1b1-8071-4816-8a0b-d252a12d7eb1.png\" alt=\"스크린샷, 2021-11-02 17-34-22\"></p>\n<p>VM의 구성 요소에 OS가 존재하는데 비해, 오른쪽의 도커 컨테이너에는 OS를 포함하고 있지 않다. 도커라는 플랫폼 위에 컨테이너들이 올라가 있고, 그 아래 호스트 OS가 존재하고있다.</p>\n<p>이를 통해, 각 컨테이너는 호스트 OS의 커널(Kernel, 시스템 콜과 같이 OS의 핵심 기능을 구현한 프로그램)을 공유하고 있음을 짐작할 수 있다. 즉, 도커는 애플리케이션을 컨테이너화해서 실행하는 데에 주 목적이 있으므로, VM과 다르게 컨테이너에 OS를 올려서 사용하지 않기에 리소스가 적다. 호스트 OS의 입장에서 본다면 컨테이너 하나는 프로세스 하나에 불과하다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<hr>\n<ul>\n<li>\n<p>도커를 왜 쓰는지 이유는 확실히 알았다.</p>\n<p>서로 다른 배포환경에서 특정 환경에 종속되지 않고 개발과 배포를 원활히 이뤄질 수 있게 해주는 하나의 생태계이다.</p>\n</li>\n</ul>\n<br>\n<br>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li>\n<p><a href=\"#1-docker\">1. Docker</a></p>\n<ul>\n<li><a href=\"#1-1-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88\">1-1. 리눅스 컨테이너</a></li>\n<li><a href=\"#1-2-%EC%9D%B4%EB%AF%B8%EC%A7%80\">1-2. 이미지</a></li>\n<li><a href=\"#1-3-docker-cli\">1-3. Docker CLI</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-vm%EC%9D%98-%EB%B9%84%EA%B5%90\">2. 컨테이너와 VM의 비교</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>\n</div>","excerpt":"✍️ Today I Learned 1. Docker 도커(Docker)는 쉽게 애플리케이션을 추상화 하고, 컨테이너 방식으로 실행할 수 있게 해주는 리눅스 컨테이너기반의 오픈소스 가상화 플랫폼중 가장 대표적인 종류 중 하나이다 1-1. 리눅스 컨테이너 개발자들은 개별적인 로컬 환경에서 작업하며 특정하게 설정된 환경을 사용하고 있으며, 현재 개발 중인 애플리케이션은 특정 라이브러리, 종속성 및 파일에 의존하고 있다. 이러한 애플리케이션을 배포할때 임의의 환경에서도 애플리케이션이 작동되게 하고, 품질 검사를 통과하고, 큰 문제나 수정 없이 애플리케이션을 배포하려면 리눅스 컨테이너(LXC) 를 사용해야 한다. 컨테이너는 다음 세가지의 자원을 독립적으로 격리하며 소유하고 있다. 프로세스 특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스할 수 있다. 컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향을 줄 수 없다. 네트워크 기본으로 컨테이너 하나…","frontmatter":{"date":"November 02, 2021","title":"Docker, 컨테이너와 VM의 비교","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2021-11-02-TIL/"}},"next":{"id":"5c8c7494-04f4-5237-9d5b-47ae2e12681d","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECA//EABUBAQEAAAAAAAAAAAAAAAAAAAAF/9oADAMBAAIQAxAAAAHSaSawD//EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIU/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CIv8A/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERIDH/2gAIAQEAAT8hGb2Ff//aAAwDAQACAAMAAAAQHD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAACAwEAAAAAAAAAAAAAAAABEQAgQVH/2gAIAQEAAT8QjVhju1//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"github-blog.png\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/TIL.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/TIL.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/TIL.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/TIL.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<hr>\n<br>\n<h3 id=\"1-amazon-web-service\" style=\"position:relative;\"><a href=\"#1-amazon-web-service\" aria-label=\"1 amazon web service permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Amazon Web Service</h3>\n<hr>\n<ul>\n<li>\n<p>웹 서비스 배포를 위한 방법으로 가상화 기술(가상의 컴퓨터를 대여)을 사용하는 클라우드 컴퓨팅을 사용할 수 있다.</p>\n</li>\n<li>\n<p>클라우드 컴퓨팅 서비스 중 가장 유명한 것이 Amazon Web Service(AWS)이다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-1-cloud-computing\" style=\"position:relative;\"><a href=\"#1-1-cloud-computing\" aria-label=\"1 1 cloud computing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. Cloud Computing</h4>\n<hr>\n<ul>\n<li>\n<p>클라우드 등장 이전의 방식은 흔히 말하는 전산실 등에 컴퓨터를 배치하고 인터넷을 연결하여 서비스를 제공했다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/83164003/144698139-d85f1899-2867-4e66-9ddd-e045bd12bfde.jpeg\"></center><br>\n<p>하지만 이러한 경우 서버가 요청에 대한 수용 능력이 한계에 도달한다면 같은 공간에 서버를 추가하거나 서버의 성능을 업그레이드하는 방식을 채택해야한다.</p>\n</li>\n<li>\n<p>이러한 방식의 문제는 몇가지 문제점을 가지고 있다.</p>\n<ol>\n<li>\n<p><strong>주기적인 관리가 필요</strong> : 흔히 말하는 서버실에는 종종 고장이 나거나 인터넷과 연결이 되지 않는 얘기치 못한 문제가 생기기도 한다.<br>\n이런 상황이 발생한다면 규모가 작은 서버라도 이를 해결하기 위한 인력 및 비용이 불가피하게 투입되어야 문제 해결이 가능하다.</p>\n</li>\n<li>\n<p><strong>공간의 한계</strong> : 둘째로 발생하는 문제점은 물리적인 공간의 문제점이다. 서버실이라는 공간에 컴퓨터를 배치해 두고 발생하는 트래픽에따라 서버를 추가하는 방식으로 서버의 수용 능력을 향상해야하지만, 트래픽이 매우 많아지는 경우 물리적인 공간에 제약이 생길수가 있다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>이러한 물리적인 문제점들을 극복하기 위하여 나온 개념이 서버의 자원과 공간, 및 네트워크 환경을 외부로 부터 제공을 빌려 받아 사용하는 <strong>클라우드 컴퓨팅</strong>이다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-2-클라우드의-등장\" style=\"position:relative;\"><a href=\"#1-2-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-label=\"1 2 클라우드의 등장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. 클라우드의 등장</h4>\n<hr>\n<ul>\n<li>\n<p>앞서 말한 서버의 자원과 공간, 및 네트워크 환경을 빌려주는 곳을 데이터 센터라 일컫는다. (이러한 환경을 <strong>온프레미스</strong>라 부르며, 반대 개념인 <strong>오프프레미스</strong>는 위에서 말한 서버실같은 환경을 말한다.)</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144698437-cb81a76c-a0ae-4be8-bf98-f587e7316ecd.png\" alt=\"스크린샷, 2021-12-04 14-24-55\"></p>\n</li>\n<li>\n<p>클라우드 컴퓨팅은 앞서 설명한 데이터센터같은 온프레미스 환경과 비슷한 역할을 하지만, 물리적인 컴퓨터가 아닌 가상 컴퓨터를 대여한다는 점이 다르다.</p>\n</li>\n<li>\n<p>온프레미스 환경과 다르게 가상화(Virtualization) 기술을 가진 클라우딩 컴퓨터가 갖는 이점은 다음과 같다.</p>\n<ol>\n<li>사용이 필요할 때마다 컴퓨팅 능력을 유연하게 조절할 수 있다.</li>\n<li>이용기간에 따라 고정적인 비용이 들어가는 온프레미스(정액제)와는 달리 사용한 만큼의 요금(정량제)만 지불이 가능하다.</li>\n</ol>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-3-클라우드의-단점\" style=\"position:relative;\"><a href=\"#1-3-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"1 3 클라우드의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-3. 클라우드의 단점</h4>\n<hr>\n<ul>\n<li>\n<p>앞서 말한 장점이 뚜렷한 클라우드 컴퓨팅이지만, 이러한 환경에도 단점은 존재한다.</p>\n</li>\n<li>\n<p>클라우드 제공자(AWS,Google 등..)의 환경에 문제가 있을 경우 해당 서비스 사용자들이 모두 영향을 받는다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144698955-79fd690a-ac53-4241-a7f8-3c4f3d3d9298.jpg\" alt=\"쿠키런 장애\"></p>\n<p>클라우드 서비스에 100% 의존하는 경우, 운영 환경 자체가 클라우드 제공자에게 종속되어 버리므로 클라우드 서비스에 문제가 생기면 내가 배포하고 관리하는 환경에도 영향이 미친다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-4-클라우드의-목표\" style=\"position:relative;\"><a href=\"#1-4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"1 4 클라우드의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-4. 클라우드의 목표</h4>\n<hr>\n<ul>\n<li>\n<p>이러한 클라우드의 목표는 모든 것을 서비스화하는 것을 목표로 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144699128-fba05602-dc78-4b98-aa28-482a49df20d1.png\" alt=\"스크린샷, 2021-12-04 14-49-04\"></p>\n<p>대표적인 클라우드 서비스의 형태는 SaaS, IaaS, PaaS 세 가지이다.</p>\n<ol>\n<li><strong>SaaS</strong> (Software as a Service)</li>\n</ol>\n<ul>\n<li>클라우드 제공자가 당장 사용 가능한 소프트웨어를 제공하는 경우 대부분 SaaS에 해당한다.</li>\n<li>드롭박스, 구글드라이브, 넷플릭스 등</li>\n</ul>\n<ol start=\"2\">\n<li><strong>PaaS</strong> (Platform as a Service)</li>\n</ol>\n<ul>\n<li>클라우드 제공자가 데이터베이스, 개발 플랫폼까지 제공하는 경우 대부분 PaaS에 해당한다.</li>\n<li>Oracle Cloud 플랫폼 등</li>\n</ul>\n<ol start=\"3\">\n<li><strong>IaaS</strong> (Infrastructure as a Service)</li>\n</ol>\n<ul>\n<li>클라우드 제공자가 가상 컴퓨터까지 제공하는 경우 대부분 IaaS에 해당한다.</li>\n<li>AWS 등</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<h3 id=\"2-aws-배포-실습\" style=\"position:relative;\"><a href=\"#2-aws-%EB%B0%B0%ED%8F%AC-%EC%8B%A4%EC%8A%B5\" aria-label=\"2 aws 배포 실습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. AWS 배포 실습</h3>\n<hr>\n<ul>\n<li>클라우드 컴퓨팅의 개념에 대해서는 학습했으니, 실제 웹 애플리케이션을 배포하는 과정을 간단히 실습해보자.</li>\n</ul>\n<br>\n<br>\n<h4 id=\"2-1-백엔드-배포\" style=\"position:relative;\"><a href=\"#2-1-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC\" aria-label=\"2 1 백엔드 배포 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. 백엔드 배포</h4>\n<hr>\n<ul>\n<li>\n<p>AWS에서 서버 배포시 다음과 같은 과정이 필요하다.</p>\n<ul>\n<li>EC2 콘솔을 통해 EC2 인스턴스를 생성해야 한다.</li>\n<li>간단한 서버 애플리케이션을 생성하고 EC2 인스턴스에 코드를 배포해야 한다.</li>\n<li>서버를 실행시키고 브라우저에서 서버에 접속할 수 있어야 한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"ec2-인스턴스-생성\" style=\"position:relative;\"><a href=\"#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1\" aria-label=\"ec2 인스턴스 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EC2 인스턴스 생성</h5>\n<hr>\n<ul>\n<li>\n<p>AWS 메뉴에서 EC2 서비스를 검색하고 접속하여 인스턴스 시작 버튼을 클릭하여 인스턴스 생성을 시작하자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144700723-1894003b-df7b-473e-850b-e5338ce795bc.png\" alt=\"스크린샷, 2021-12-04 15-30-52\"></p>\n</li>\n<li>\n<p>용도에 맞게 AMI를 선택하는 과정이다. 호환성 이슈 및 프리티어 지원여부를 고려하여 ubuntu 18.04 버전을 선택해주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144700759-56e500b3-fb45-4f2e-b189-eb21bec1216b.png\" alt=\"스크린샷, 2021-12-04 15-54-09\"></p>\n</li>\n<li>\n<p>인스턴스 유형을 선택하는 과정이다. 생성하는 인스턴스의 CPU, RAM, 용량에 대한 선택이 가능하지만.. 프리티어가 지원되는 유형을 선택하자. <del>(램 1GB실화..??)</del></p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144700808-a896fbdd-5503-4758-8419-61b55a5ec6ba.png\" alt=\"스크린샷, 2021-12-04 15-56-28\"></p>\n</li>\n<li>\n<p>검토 및 시작 버튼을 클릭하면 이제 인스턴스를 원격으로 제어하기 위해서 보안키를 선택하거나(기존의 키가 있는 경우) 새로 생성하라는 안내화면이 나온다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144700959-43b75f01-a9e6-4985-b543-f6525b25a22e.png\" alt=\"스크린샷, 2021-12-04 16-01-01\"></p>\n<p>키 페어 다운로드를 해준뒤 내 로컬 PC환경에 보관해주자.</p>\n<p>해당 과정으로 생성되는 키로 인스턴스를 SSH* 연결을 통해 원격으로 제어할 수 있다.</p>\n<blockquote>\n<p><strong>SSH 프로토콜</strong>이란?</p>\n<p>SSH는 서로 다른 PC가 인터넷과 같은 Public Network를 통해 통신을 할 때 보안상 안전하게 통신을 하기 위한 통신 규약이다.</p>\n<p>주고받는 데이터를 암호화해서 해당 키 페어를 가지지 않은 사람은 통신되는 데이터를 알아볼 수 없기 때문에 보안상 안전한 통신 방법이다.</p>\n</blockquote>\n</li>\n<li>\n<p>인스턴스 생성 마지막 단계에서 다운로드 한 파일은 SSH 통신을 위한 키 페어 중 프라이빗 키가 기록된 파일이다. (.pem 확장자를 가지고 있다.)</p>\n<p>해당 키 페어 파일은 EC2 인스턴스에 원격으로 연결을 할때 사용하는 암호가 담긴 파일이므로 외부에 노출안되게 관리에 유념해야한다.</p>\n</li>\n<li>\n<p>이제 해당 키를 이용하여 SSH 원격 연결로 생성한 인스턴스로 들어가 보자.<br>\n생성한 인스턴스의 아이디를 누르면 인스턴스 상세정보를 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701274-8beecce2-e522-43ad-b4c8-0769c5674cd3.png\" alt=\"스크린샷, 2021-12-04 16-09-02\"></p>\n<p>그 뒤 연결 탭을 누르면 인스턴스에 접속하는 옵션들을 선택할 수 있게된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701333-eca5e982-dc85-430b-a505-0f6f0ac08bfb.png\" alt=\"스크린샷, 2021-12-04 16-16-59\"></p>\n<p>우린 SSH 방식으로 연결할 예정이므로 SSH 클라이언트 탭을 눌러 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701373-07137bd2-a4c3-4f25-a6d2-16819ce12f76.png\" alt=\"스크린샷, 2021-12-04 16-18-19\"></p>\n</li>\n<li>\n<p>SSH프로토콜을 이용하면 로컬 터미널 환경으로 클라우드 컴퓨팅 인스턴스와 연결이 가능하다.<br>\n다만, 다운로드했던 키 페어 파일(.pem)이 누구나 접근할 수 있는 권한이 부여되어 있다면 인스턴스는 연결을 거부한다.</p>\n<p>그러므로 다운로드 했던 키 페어 파일이 위치의 디렉토리 위치에서 터미널 환경으로 해당 키 페어 파일의 권한을 수정해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701462-f4a77d39-8ffb-400c-b005-5f7caf2a29a5.png\" alt=\"스크린샷, 2021-12-04 16-21-01\"></p>\n<p>키 페어 파일(.pem)의 권한을 수정하지 않은 경우, 권한이 너무 open 되어 있다는 경고 메시지와 함께 접속이 거절된다.</p>\n</li>\n<li>\n<p>이제 키 페어를 알맞은 권한으로 사용하여 SSH 프로토콜 환경으로 EC2 인스턴스로 원격 접속이 가능하게 모두 설정이 완료되었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701564-dba0f2fd-5448-4861-8a05-857c0ad6bd23.png\" alt=\"스크린샷, 2021-12-04 16-25-49\"></p>\n<p>위 명령어를 통해 내 로컬 디렉토리(키페어가 들어있는 디렉토리)에서 터미널 환경에서 인스턴스로 접속을 시도하면 아래와 같은 인스턴스 원격 접속 화면을 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701568-d58f3d8e-3442-4173-8605-57d8bec8e23f.png\" alt=\"스크린샷, 2021-12-04 16-25-28\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"vscode를-이용한-ssh-원격-접속\" style=\"position:relative;\"><a href=\"#vscode%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ssh-%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D\" aria-label=\"vscode를 이용한 ssh 원격 접속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VSCode를 이용한 SSH 원격 접속</h5>\n<hr>\n<ul>\n<li>\n<p>위와 같이 터미널 환경으로도 인스턴스에 접속하여 충분히 조작이 가능하지만 불편하다.</p>\n<p>아무래도 GUI를 통한 사용자에게 편한 조작방식과는 거리가먼 명령어로만 작동하는 방식이기때문이다.</p>\n</li>\n<li>\n<p>VSCode 확장 툴인 <strong>Remote Development</strong>를 이용하면, 편리하게 SSH 원격 접속이 가능하다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701685-13cb8b99-819b-4e55-ad09-76acab052d54.png\" alt=\"스크린샷, 2021-12-04 16-32-03\"></p>\n<p>위의 두 확장 툴을 받아주면, VSCode 좌측 툴에 다음과 같은 원격 탐색기 아이콘이 생성된 걸 확인할 수 있다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/83164003/144701727-bf2ea8a2-923c-4af9-8a80-8deb59c595e5.png\"></center>\n</li>\n<li>\n<p>이제 SSH Configure 로 가서 원격접속을 위한 설정을 해주자</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144701931-6d64efc3-b774-4cad-bb1d-9f03ad3c0166.png\" alt=\"스크린샷, 2021-12-04 16-42-57\"></p>\n<ul>\n<li><strong>Host</strong> : 원하는 아무 Host 명을 입력해주자, VSCode에서 구분하기 위한 이름이다.</li>\n<li><strong>HostName</strong> : EC2 퍼블릭 DNS, 원격 접속할 EC2 인스턴스의 주소이다.</li>\n<li><strong>User</strong> : 서버 접속 계정명을 입력해주자.</li>\n<li><strong>IdentityFile</strong> : .pem 키 페어가 담긴 디렉토리 위치를 입력해주자.</li>\n</ul>\n</li>\n<li>\n<p>올바르게 SSH 환경 설정이 완료되면 VSCode에서 EC2 인스턴스로 원격 접속이 가능하게 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144702113-29bd3c71-b164-43d7-bfe0-c70f25359286.png\" alt=\"스크린샷, 2021-12-04 16-51-37\"></p>\n<p>로컬 터미널 환경보다는 <del>훨씬</del> 편하게 폴더 및 파일 수정을 할 수 있게 된다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"ec2-인스턴스-상에서-서버-실행\" style=\"position:relative;\"><a href=\"#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%81%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84-%EC%8B%A4%ED%96%89\" aria-label=\"ec2 인스턴스 상에서 서버 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EC2 인스턴스 상에서 서버 실행</h5>\n<hr>\n<ul>\n<li>\n<p>이제 생성된 EC2 인스턴스는 ubuntu 18.04 운영체제가 탑제된 텅텅 빈 가상 PC이다.</p>\n<p>해당 인스턴스를 서버가 구동될 수 있는 개발환경을 구성하여 인스턴스에서 서버를 구동시키는 방식은 로컬 개발환경을 구축하는 방식과 동일하므로 생략하도록 하겠다.</p>\n</li>\n<li>\n<p>Github Repository에서 가져올 서버환경을 간략히 설명하자면, HTTP 방식으로 80번 포트를 사용하는 서버이며, 각 엔드포인트로의 요청은 다음과 같이 처리된다.</p>\n<ul>\n<li><code class=\"language-text\">/</code> : GET 요청</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">201</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>응답코드 201번으로 ‘Hello World’ 응답 메세지를 보내주는 간단한 구조이다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">/signin</code> : POST 요청</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/signin'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> username<span class=\"token punctuation\">,</span> password <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>username <span class=\"token operator\">===</span> <span class=\"token string\">'김코딩'</span> <span class=\"token operator\">&amp;&amp;</span> password <span class=\"token operator\">===</span> <span class=\"token string\">'1234'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> accessToken <span class=\"token operator\">=</span> jwt<span class=\"token punctuation\">.</span><span class=\"token function\">sign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> username <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'secretKey'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">expiresIn</span><span class=\"token operator\">:</span> <span class=\"token string\">'1days'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">201</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>accessToken<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">401</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Login Failed'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">req.body</code>에 담긴 username, password가 각각 ‘김코딩’, ‘1234’인 경우 <code class=\"language-text\">accessToken</code>을 생성하여 (유효기간 1일) 응답코드에 토큰을 담아 전달해주는 구조이다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">/status</code> : GET 요청</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/status'</span><span class=\"token punctuation\">,</span> authToken<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// jwt 토큰이 존재할 경우 데이터베이스 연결 여부 조회</span>\n    db<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'use test'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n          <span class=\"token literal-property property\">isLogin</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          <span class=\"token literal-property property\">isConnectedToDatabase</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">isLogin</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">isConnectedToDatabase</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>로그인에 성공시 DB 연결 여부에따라 다른 결과를 보여주는 마지막 엔드포인트이다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>위 accessToken은 로컬 스토리지에 담기며, 인증서 없이 80번 포트에서 HTTP 방식으로 서버가 구동되는 구조를 확인하였다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"security-group\" style=\"position:relative;\"><a href=\"#security-group\" aria-label=\"security group permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Security Group</h5>\n<hr>\n<ul>\n<li>\n<p>이제 서버를 VSCode SSH 원격 접속환경에서 실행시켜주면 80번 포트로 작동하는 걸 확인 할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144842989-885e45e8-6253-4840-9a3e-70cb38ba9534.png\" alt=\"스크린샷, 2021-12-06 21-03-56\"></p>\n<p>AWS EC2 인스턴스로 접속하여 부여된 퍼블릭 IPv4 DNS 주소로 접근을 하면 다음과 같은 도메인 접속 불가 에러코드를 확인 할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144843062-c3626eaf-28e0-488e-a854-c328b2b4e425.png\" alt=\"스크린샷, 2021-12-06 20-58-52\"></p>\n<p>아직 인스턴스 외부 접근을 위한 <strong>보안 그룹</strong> 설정을 하지 않았기 때문이다.</p>\n</li>\n<li>\n<p>보안 그룹(Security Group)은 우리가 AWS에서 임대한 인스턴스의 가상 방화벽이다.</p>\n<p>인스턴스로 들어가는 트래픽을 제어하는 인바운드 설정과 인스턴스에서 나가는 트래픽을 제어하는 아웃바운드 설정 두가지 보안그룹 설정이 존재한다.</p>\n</li>\n<li>\n<p>아웃바운드의 default값은 EC2 인스턴스에서 외부로 나가는 모든 트래픽이 허용되므로, 우리는 외부에서 접근하는 인바운드 설정만 해주면된다.</p>\n<p>현재 인스턴스의 보안그룹으로 들어가주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144844163-2a4c413b-9cb5-443f-a0f0-cabc9acca5da.png\" alt=\"스크린샷, 2021-12-06 21-13-26\"></p>\n<p>인바운드/ 인바운드 규칙 편집을 클릭 후 다음과 같이 80번 포트의 인바운드 규칙을 설정해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144844679-54838d26-e4c0-48b8-819c-63b59f54d749.png\" alt=\"스크린샷, 2021-12-06 21-15-10\"></p>\n<p>이제 인스턴스에서 서버가 켜진 상태에서 다시 퍼블릭 IPv4 DNS 주소로 접속시 ‘Hello World’ 문구를 확인 할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144845244-a7759042-6b95-4734-a2db-86e47bfafa49.png\" alt=\"스크린샷, 2021-12-06 21-21-45\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"서버-백그라운드-실행\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89\" aria-label=\"서버 백그라운드 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 백그라운드 실행</h5>\n<hr>\n<ul>\n<li>\n<p>SSH 프로세스는 강제 종료 시(로컬 환경 터미널 종료시), EC2 상의 프로세스도 같이 종료된다.</p>\n<p>그러므로 우리는 SSH 프로세스가 종료되더라도 서버가 EC2 백그라운드에서 작동하게끔 프로그램을 실행해줘야 한다.</p>\n</li>\n<li>\n<p>Linux/Unix 계열 운영체제에서는 <code class=\"language-text\">&amp;</code>라는 키워드를 붙여서 프로그램 실행시 백그라운드 실행으로 만들어줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ node index.js &amp;</code></pre></div>\n<p>위 명령어를 사용하여 서버를 작동시켜주자</p>\n<ul>\n<li>반대로 서버를 종료하고 싶다면 kill 명령을 통해 백그라운드에서 실행중인 프로세스를 종료할 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"2-2-프론트엔드-배포\" style=\"position:relative;\"><a href=\"#2-2-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC\" aria-label=\"2 2 프론트엔드 배포 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. 프론트엔드 배포</h4>\n<hr>\n<ul>\n<li>프론트엔드는 S3 버킷을 이용하여 클라이언트가 담긴 정적 웹 사이트를 호스팅 해주어야 한다.</li>\n</ul>\n<br>\n<br>\n<h5 id=\"s3-버킷-생성\" style=\"position:relative;\"><a href=\"#s3-%EB%B2%84%ED%82%B7-%EC%83%9D%EC%84%B1\" aria-label=\"s3 버킷 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>S3 버킷 생성</h5>\n<hr>\n<ul>\n<li>\n<p>이제 AWS 홈페이지의 S3 버킷으로 접속 후, 버킷만들기로 버킷을 생성해 주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144847449-208d76c3-4155-4c3e-98a5-4781b88caf4c.png\" alt=\"스크린샷, 2021-12-06 21-38-12\"></p>\n<p>버킷이름을 설정해줘야한다.<br>\n다만, 한 리전에는 하나의 버킷이름만 생성이 가능하다. 중복이 불가능하므로 고유한 버킷명을 적어주고 별다른 설정없이 인스턴스와 같은 리전에서 버킷을 생성해 주자.</p>\n</li>\n<li>\n<p>이제 만들어진 버킷의 이름을 클릭하여 속성 메뉴로 진입 후, 정적 웹 사이트 호스팅 메뉴로 들어가 아래와 같이 수정해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144847908-0d550aa1-58e6-4628-8f92-3054ed94fb0e.png\" alt=\"스크린샷, 2021-12-06 21-41-05\"></p>\n<p>정적 웹사이트 호스팅을 활성화를 버튼을 눌러주면, 인덱스 문서등 여러 옵션 선택창이 나온다.</p>\n<p>해당 버킷 웹 사이트 주소에 처음 접속했을 때 보일 기본 페이지를 지정해주는 옵션과 혹시 모를 오류 발생 시 메인 페이지를 반환하기 위해서 <strong>index.html</strong>을 기입해 준다.</p>\n</li>\n<li>\n<p>이제 클라이언트를 담을 S3 버킷이 완성되었다. 버킷 속성 메뉴 진입 후 버킷 웹 사이트 엔드포인트로 접속하면 이제 우리가 만든 버킷 영역으로 접속이 가능하다.</p>\n<p>—<img src=\"https://user-images.githubusercontent.com/83164003/144848531-bef2e5b4-849c-4e68-9ed8-4663c8f69c42.png\" alt=\"스크린샷, 2021-12-06 21-46-35\"></p>\n<p>이제 버킷에 정적 웹 페이지 파일을 아직 업로드 하고, 퍼블릭 액세스 설정 변경과 정책 생성을 해주면 클라이언트가 웹 상에 호스팅되게 된다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"버킷에-웹-페이지-파일-업로드\" style=\"position:relative;\"><a href=\"#%EB%B2%84%ED%82%B7%EC%97%90-%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8C%8C%EC%9D%BC-%EC%97%85%EB%A1%9C%EB%93%9C\" aria-label=\"버킷에 웹 페이지 파일 업로드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>버킷에 웹 페이지 파일 업로드</h5>\n<hr>\n<ul>\n<li>\n<p>우선 <code class=\"language-text\">im-sprint-practice-deploy</code>/<code class=\"language-text\">client</code>/<code class=\"language-text\">.env.example</code> 파일을 VSCode SSH 환경으로 접속하여 서버의 주소(퍼블릭 IPv4 DNS 주소)로 환경변수 설정을해준다.</p>\n</li>\n<li>\n<p>환경 변수 관련 설정이 완료 후, client 디렉토리에서 터미널 <code class=\"language-text\">npm run build</code> 명령어를 통해 빌드 파일을 생성해주자.</p>\n<center><img src=\"https://user-images.githubusercontent.com/83164003/144846947-945598bf-cf0d-4e6c-8553-8cd8e08f5206.png\"></center><br>\n<p>빌드가 성공하면, 위와 같은 폴더가 생성된다.</p>\n<p>이 빌드된 파일들을 버킷에 올려주어야 한다.</p>\n</li>\n<li>\n<p>이전에 생성한 S3 버킷의 ID 클릭 후 객체 메뉴의 업로드를 선택해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144849536-07c7600d-a8f1-46a0-ba5f-84fd21368ac4.png\" alt=\"스크린샷, 2021-12-06 21-52-48\"></p>\n<p>위와 같은 화면이 나오면 방금 빌드된 폴더를 업로드 해준다.</p>\n<p>EC2 인스턴스에서 빌드된 파일을 로컬환경으로 가져오려면 VSCode SSH 연결이 되어있다면 이동할 디렉토리 우클릭 후 다운로드하여 로컬환경으로 가져올 수 있다.</p>\n<center><img src=\"https://user-images.githubusercontent.com/83164003/144849810-2c2ef28e-b132-4ba1-b7d8-1fc509388a3e.png\"></center>\n</li>\n<li>\n<p>이제 버킷에 웹 페이지 파일까지 모두 완료되었으니, 버킷으로 접근 권한 설정과 버킷 정책 생성을 해주어야 한다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"버킷-권한-설정\" style=\"position:relative;\"><a href=\"#%EB%B2%84%ED%82%B7-%EA%B6%8C%ED%95%9C-%EC%84%A4%EC%A0%95\" aria-label=\"버킷 권한 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>버킷 권한 설정</h5>\n<hr>\n<ul>\n<li>\n<p>이제 버킷 메뉴중 권한 메뉴로 들어 간 뒤, 퍼블릭 액세스 차단(버킷 설정) 편집을 해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144850311-b24597c9-cb40-453a-bc2d-bca7f2bdfa58.png\" alt=\"스크린샷, 2021-12-06 21-58-35\"></p>\n<p>모든 퍼블릭 액세스 차단 옵션의 체크 박스를 해제해 준다.</p>\n<p>그리고 이제 버킷 정책을 설정해 주어야 한다.<br>\n버킷 정책 편집 버튼으로 들어 간 뒤 버킷 ARN을 복사 후 버킷 정책 생성기로 들어간다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144850714-ab4956d8-44cc-400e-b88f-049715b544d1.png\" alt=\"스크린샷, 2021-12-06 22-02-02\"></p>\n<p>정책 생성기에 접속 후 아래 사진과 같이 정책을 생성해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144850969-0fae56c2-dd48-4ce4-9088-e7214f893f60.png\" alt=\"스크린샷, 2021-12-06 22-03-25\"></p>\n<p>위에서 부터 차례대로 <code class=\"language-text\">S3 Bucket Policy</code> 선택 후 Effect는 Allow로 기본으로 체크되어 있다.</p>\n<p>Principal은 <code class=\"language-text\">*</code>을 입력 해 준 뒤, Actions에서는 <code class=\"language-text\">GetObject</code>1가지 액션만 선택한다.</p>\n<p>마지막으로 Amazon Resource Name (ARN)은 미리 복사한 내 버킷 ARN을 복사 후 <code class=\"language-text\">/*</code>를 뒤에 붙여서 입력해 준뒤 정책을 생성해준다.</p>\n</li>\n<li>\n<p>생성된 정책을 내 버킷 정책에 붙여넣기로 넣어 준 뒤,</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144851729-9f691a45-7f36-4b3d-9890-11b4a0d6dd9d.png\" alt=\"스크린샷, 2021-12-06 22-09-59\"></p>\n<p>EC2 인스턴스에서 서버가 접속중인 상태에서 버킷 엔드포인트로 접속해 주면 다음과 같은 화면을 확인 할 수 있다.</p>\n<img width=\"795\" alt=\"wUMGKH3xh-1618474509693\" src=\"https://user-images.githubusercontent.com/83164003/144852123-c05b18d2-5899-42fb-96c6-33b9b4bc30ff.png\">\n<img width=\"746\" alt=\"ssWhmZWQO-1618474630640\" src=\"https://user-images.githubusercontent.com/83164003/144852104-07bddf18-a447-42a7-92eb-d2551b95fc2b.png\">\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"2-3-데이터베이스-연결\" style=\"position:relative;\"><a href=\"#2-3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EA%B2%B0\" aria-label=\"2 3 데이터베이스 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. 데이터베이스 연결</h4>\n<hr>\n<ul>\n<li>MySQL 데이터베이스 엔진을 사용하는 DB 인스턴스를 생성한 뒤 EC2 인스턴스와 해당 DB를 연결하는 과정으로 완성된다.</li>\n</ul>\n<br>\n<br>\n<h5 id=\"rds-인스턴스-생성\" style=\"position:relative;\"><a href=\"#rds-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1\" aria-label=\"rds 인스턴스 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDS 인스턴스 생성</h5>\n<hr>\n<ul>\n<li>\n<p>AWS RDS 메뉴로 진입 후 데이터베이스를 생성해주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144853927-fe77299c-62c3-4a32-84ef-e2cf0e54a8ed.png\" alt=\"스크린샷, 2021-12-06 22-24-58\"></p>\n<p>엔진옵션은 MySQL을 선택 후 프리티어로 선택한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144854149-c8db7da3-c542-47fe-995c-a3f7398ed993.png\" alt=\"스크린샷, 2021-12-06 22-26-49\"></p>\n<p>자격증명 옵션에서는 마스터 사용자 이름 설정과 8자리 이상의 사용자 비밀번호를 설정해 주자. (마스터 사용자 이름과 비밀번호는 나중에 데이터베이스를 연결할 때 쓰이는 정보이다.)</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144854487-8193fb95-f817-40b9-8ac8-97b98d0d4d73.png\" alt=\"스크린샷, 2021-12-06 22-29-10\"></p>\n<p>연결 옵션에서는 퍼블릭 액세스를 “예”로 변경해 준 뒤,</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144854619-38337e5f-cee5-49d3-9f05-cebc0a56a7d5.png\" alt=\"스크린샷, 2021-12-06 22-30-28\"></p>\n<p>추가구성으로 가서 포트번호를 13306번으로 변경해 주었다. (흔히 사용되는 3306번 포트 대신, 포트번호 노출을 방지하려는 목적으로 13306번 포트를 사용하였다.)</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144854825-e076124f-a9cf-4829-b8a0-7199f379ac2c.png\" alt=\"스크린샷, 2021-12-06 22-31-38\"></p>\n<p>마지막으로 서버에서 연결된 DB 초기값이 test 이름이므로 초기 데이터베이스 명칭을 test로 주었다. (생략 후 MySQL 접속 후 CREATE DATABASE test를 실행해 주어도 된다.)</p>\n</li>\n<li>\n<p>위 과정을 마치면 DB 생성이 진행된다.</p>\n<p>생성이 모두 완료되는데 시간은 2~30분정도 소요되는듯 하다.</p>\n</li>\n<li>\n<p>생성이 완료되면 DB 인스턴스 아이디 클릭 후 연결&#x26;보안의 DB 엔드포인트 주소를 복사해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144855391-157d300c-7948-487f-bea5-37e4061615ed.png\" alt=\"스크린샷, 2021-12-06 22-35-26\"></p>\n<p>MySQL이 설치된 환경에서 <code class=\"language-text\">mysql -u [마스터 이름] --host [엔드포인트 주소] -P 13306(포트번호) -p</code> 명령어를 입력 후 마스터 사용자 이름과 비밀번호를 입력하면 DB 인스턴스로 접속이 가능하다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144856074-398eb02c-788f-4140-ab9e-28f0e70db7f7.png\" alt=\"스크린샷, 2021-12-06 22-40-02\"></p>\n<p>초기 데이터베이스인 test가 확인되면 완료이다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h5 id=\"rds-인스턴스-연결\" style=\"position:relative;\"><a href=\"#rds-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%97%B0%EA%B2%B0\" aria-label=\"rds 인스턴스 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDS 인스턴스 연결</h5>\n<hr>\n<ul>\n<li>\n<p>EC2 인스턴스에서 실행되고 있는 서버는, 그 자체로는 작동하고 있지만, 아직 데이터베이스에 연결은 안되어 있다.</p>\n<p>서버의 환경 설정을 통해서 위에서 생성한 RDS 인스턴스에 접속 하면 클라우드 데이터베이스 test DB를 사용할 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">im-sprint-practice-deploy</code>/<code class=\"language-text\">server</code>/<code class=\"language-text\">db</code>/<code class=\"language-text\">connection.js</code> 파일을 확인 하면 아래와 같은 코드를 확인 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> mysql <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mysql'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dotenv <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dotenv'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndotenv<span class=\"token punctuation\">.</span><span class=\"token function\">config</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> con <span class=\"token operator\">=</span> mysql<span class=\"token punctuation\">.</span><span class=\"token function\">createConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">host</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">DATABASE_HOST</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">user</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">DATABASE_USER</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">password</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">DATABASE_PASSWORD</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">port</span><span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">DATABASE_PORT</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ncon<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    con<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> con<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>다시 VSCode SSH 로 접속하여 <code class=\"language-text\">im-sprint-practice-deploy</code>/<code class=\"language-text\">server</code>/<code class=\"language-text\">.env.example</code>를 알맞게 수정해 준 뒤 서버를 재시작하자. (<code class=\"language-text\">host</code>는 생성한 DB 인스턴스의 엔드포인트 주소를 넣어준다.)</p>\n</li>\n<li>\n<p>서버를 다시 구동한 뒤, 클라이언트에서 로그인 하면 다음과 같은 화면을 확인 할 수 있다.</p>\n<img width=\"634\" alt=\"VJm6oOI7Z-1618494315919\" src=\"https://user-images.githubusercontent.com/83164003/144857364-d63b9472-3a6c-437d-a3cf-08af15e1df17.png\">\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<hr>\n<ul>\n<li>\n<p>배포…생각보다 어렵다. 아직 AWS에서 무료로 제공하는 도메인에 호스팅만 해보았다.</p>\n<p>우선 스프린트 내용대로 잘 따라는 해서 문제는 딱히 없었다만, 그 과정을 편하게 하기 위해서 VSCode에서 지원하는 SSH 원격 접속방식을 선택했다.</p>\n<p>확실히 터미널에서만 조작하는 방식보다 마우스를 이용해서 편리하게 조작할 수 있는 GUI 환경이 사람이 쓰기엔 훨씬 편한건 어쩔 수 없는듯하다.</p>\n</li>\n<li>\n<p>원하는 도메인을 구매 후 배포하는 것과 HTTPS 인증방식을 사용하는 배포방식은 나중에 다시 해봐야겠다.</p>\n</li>\n</ul>\n<br>\n<br>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li>\n<p><a href=\"#1-amazon-web-service\">1. Amazon Web Service</a></p>\n<ul>\n<li><a href=\"#1-1-cloud-computing\">1-1. Cloud Computing</a></li>\n<li><a href=\"#1-2-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%93%B1%EC%9E%A5\">1-2. 클라우드의 등장</a></li>\n<li><a href=\"#1-3-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%8B%A8%EC%A0%90\">1-3. 클라우드의 단점</a></li>\n<li><a href=\"#1-4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EC%9D%98-%EB%AA%A9%ED%91%9C\">1-4. 클라우드의 목표</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-aws-%EB%B0%B0%ED%8F%AC-%EC%8B%A4%EC%8A%B5\">2. AWS 배포 실습</a></p>\n<ul>\n<li>\n<p><a href=\"#2-1-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC\">2-1. 백엔드 배포</a></p>\n<ul>\n<li><a href=\"#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1\">EC2 인스턴스 생성</a></li>\n<li><a href=\"#vscode%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ssh-%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D\">VSCode를 이용한 SSH 원격 접속</a></li>\n<li><a href=\"#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%81%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84-%EC%8B%A4%ED%96%89\">EC2 인스턴스 상에서 서버 실행</a></li>\n<li><a href=\"#security-group\">Security Group</a></li>\n<li><a href=\"#%EC%84%9C%EB%B2%84-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89\">서버 백그라운드 실행</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-2-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC\">2-2. 프론트엔드 배포</a></p>\n<ul>\n<li><a href=\"#s3-%EB%B2%84%ED%82%B7-%EC%83%9D%EC%84%B1\">S3 버킷 생성</a></li>\n<li><a href=\"#%EB%B2%84%ED%82%B7%EC%97%90-%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8C%8C%EC%9D%BC-%EC%97%85%EB%A1%9C%EB%93%9C\">버킷에 웹 페이지 파일 업로드</a></li>\n<li><a href=\"#%EB%B2%84%ED%82%B7-%EA%B6%8C%ED%95%9C-%EC%84%A4%EC%A0%95\">버킷 권한 설정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EA%B2%B0\">2-3. 데이터베이스 연결</a></p>\n<ul>\n<li><a href=\"#rds-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1\">RDS 인스턴스 생성</a></li>\n<li><a href=\"#rds-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%97%B0%EA%B2%B0\">RDS 인스턴스 연결</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 29, 2021","title":"Amazon Web Service, AWS 배포 실습","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2021-10-29-TIL/"}},"prev":{"id":"d6e4d71e-214d-5432-860d-00d2f18eec1a","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECA//EABUBAQEAAAAAAAAAAAAAAAAAAAAF/9oADAMBAAIQAxAAAAHSaSawD//EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIU/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CIv8A/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERIDH/2gAIAQEAAT8hGb2Ff//aAAwDAQACAAMAAAAQHD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAACAwEAAAAAAAAAAAAAAAABEQAgQVH/2gAIAQEAAT8QjVhju1//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"github-blog.png\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/TIL.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/TIL.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/TIL.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/TIL.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<hr>\n<ul>\n<li>\n<p>기존에 EC2, S3, RDS를 통해 배포한 <a href=\"https://jh8459.github.io/til/21.10.29.til/\" target=\"_blank\">웹 애플리케이션</a>(21.10.29 TIL 참조)을 무료 도메인(Freenom)으로 배포하는 Advanced한 삽질 과정을 백엔드/프론트엔드 영역을 나누어 포스팅 해보려 한다.</p>\n<blockquote>\n<p><strong>주의!</strong> CloudFront에서 AWS 인증서 검증은 us-east-1(버지니아 북부) 인증서만 검증이 된다.</p>\n</blockquote>\n</li>\n<li>\n<p>s3와 CloudFront는 글로벌 지역으로 배포가 되고 ec2와 ELB는 지역 리전으로 나뉘어진다.</p>\n</li>\n<li>\n<p>클라이언트는 글로벌 리전에서 작동하므로 리전에 영향을 받진 않을 듯 하고, 서버가 탑재될 ELB 서울리전으로 두고(<em><a target=\"https://www.cloudping.info/\" target=\"_blank\">CloudPing.info</a>를 통한 속도 검증 결과 리전마다 속도차이가 명확히 있다.</em>) 개발환경을 구성하는게 서버의 응답속도 때문에 이점이 있을 듯 한데 인증서 문제 때문에 골머리가 아팠다…</p>\n</li>\n<li>\n<p>이를 간단히 해결하기 위해서 배포된 <a href=\"https://cmarket.cf\" target=\"_blank\"><a href=\"https://cmarket.cf\">https://cmarket.cf</a></a> 는 us-east-1 리전에서 웹서버가 작동하게 하여(<em>CloudFront(클라이언트)와 ELB(서버) 인증서가 모두 us-east-1 동일한 인증서 1개로 해결가능</em>)간단히 해결하였다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h3 id=\"1-무료-도메인-https-aws-배포---백엔드\" style=\"position:relative;\"><a href=\"#1-%EB%AC%B4%EB%A3%8C-%EB%8F%84%EB%A9%94%EC%9D%B8-https-aws-%EB%B0%B0%ED%8F%AC---%EB%B0%B1%EC%97%94%EB%93%9C\" aria-label=\"1 무료 도메인 https aws 배포   백엔드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 무료 도메인 HTTPS AWS 배포 - 백엔드</h3>\n<hr>\n<br>\n<br>\n<h4 id=\"1-1-도메인-발급\" style=\"position:relative;\"><a href=\"#1-1-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%B0%9C%EA%B8%89\" aria-label=\"1 1 도메인 발급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 도메인 발급</h4>\n<hr>\n<ul>\n<li>\n<p>도메인 주소를 이용하여 HTTPS 인증방식을 사용하려면 우선 도메인을 발급받아야 한다.</p>\n</li>\n<li>\n<p>AWS에서도 Route 53을 통한 도메인 구매가 가능하지만.. 비용부담이 발생하기도 하고 실제 상업사이트나 프로젝트/포트폴리오 목적이 아닌 학업 목적이기 때문에 무료 도메인 사이트인 <a href=\"https://www.freenom.com/en/index.html?lang=en\" target=\"_blank\">Freenom</a>에서 도메인 발급 후, 해당 도메인을 이용하였다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143876151-e7fed5c2-1b13-4d57-b97f-47440d364cde.png\" alt=\"스크린샷, 2021-11-29 22-26-24\"></p>\n<p>무료 도메인은 예고없이 사라지거나 로그인이 안되는(?)등 종잡을 수 없는 문제가 발생 할 수 있으므로..이런 부분은 감안하고 학습목적 정도로만 사용하도록 하는게 알맞은 사용방향이라 생각한다.</p>\n</li>\n<li>\n<p><a href=\"http://cmarket.cf/\" target=\"_blank\">cmarket.cf</a> 주소로 도메인을 발급 받았으며 최초 발급 후 도메인에 접속하면 DNS 설정도 안된 빈 도메인이기 때문에 아래와 같은 에러코드를 받을 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143876050-43d949bd-e541-4507-acee-b59782c602f5.png\" alt=\"스크린샷, 2021-11-29 22-23-51\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-2-elb-생성\" style=\"position:relative;\"><a href=\"#1-2-elb-%EC%83%9D%EC%84%B1\" aria-label=\"1 2 elb 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. ELB 생성</h4>\n<hr>\n<br>\n<br>\n<h5 id=\"elb란\" style=\"position:relative;\"><a href=\"#elb%EB%9E%80\" aria-label=\"elb란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ELB란?</h5>\n<hr>\n<ul>\n<li>\n<p>AWS에서 설명하는 ELB는 다음과 같다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144385209-49c0bca7-99bf-4d70-ad9a-d8bf0a76f3e8.png\" alt=\"스크린샷, 2021-12-02 17-26-39\"></p>\n<p>단순한 로드 밸런서* 역할 외에도 인증서 관리등 HTTPS 인증방식 지원까지 겸하고 있는 만능 서비스이다.</p>\n<blockquote>\n<p><strong>로드 밸런서</strong>란?</p>\n<p>하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도저하 등을 고려하여 적절히 분산처리하여 해결해주는 서비스.</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<br>\n<ul>\n<li>\n<p>ELB 서비스가 왜 필요한지 개념을 알았으니, AWS EC2 메뉴중 로드밸런서로 들어가 보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143878331-14740d1a-92f8-4bdb-8c93-ce3d7e468979.png\" alt=\"스크린샷, 2021-11-29 22-37-16\"></p>\n</li>\n<li>\n<p>로드밸런서를 생성하려보니 여러 유형을 선택 할 수 있는 선택창이 나온다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144386594-d626749f-2e92-4e78-ade4-6c52c1c7509d.png\" alt=\"스크린샷, 2021-12-02 17-36-07\"></p>\n<p>우리는 HTTPS 인증 방식을 이용할 예정이니 1번을 선택하자.</p>\n</li>\n<li>\n<p>로드 밸런서 이름을 정한 뒤,</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144386771-94d61e1d-5c20-413f-bc13-cd119bdbdd75.png\" alt=\"스크린샷, 2021-12-02 17-37-32\"></p>\n<p>네트워크 맵핑에서는 가용 영역을 모두 체크해주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144386995-f2e95a20-928a-400d-b4c0-ea5629603a37.png\" alt=\"스크린샷, 2021-12-02 17-38-35\"></p>\n<p>그리고 리스너* 를 추가해 주어야 한다.</p>\n<blockquote>\n<p><strong>리스너</strong>란?</p>\n<p>짧게 말해 리스너란, 구성한 프로토콜 및 포트를 사용해서 연결 요청을 확인하는 프로세스이다.</p>\n</blockquote>\n<br>\n<br>\n<ul>\n<li>리스너의 구성된 프로토콜/포트로 요청이 왔을때 대상그룹으로 연결(?)해주는 프로세스 같다. <del>(확실하지 않다…)</del></li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144387585-52909c76-7f0e-463f-8792-8d27ea0a532f.png\" alt=\"스크린샷, 2021-12-02 17-42-54\"></p>\n<p>리스너가 추가되면 각 리스너에 타겟 그룹을 설정해줘야 한다.</p>\n</li>\n<li>\n<p>현재 배포하려는 웹 애플리케이션은 클라이언트와 서버가 토큰을 로컬스토리지에 담아 <strong>HTTP</strong>프로토콜로 데이터를 주고받고 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144389226-eddc00a7-e610-4849-9db7-4bd16edf329e.png\" alt=\"스크린샷, 2021-12-02 17-51-26\"></p>\n<p>그렇기 때문에 클라이언트 ⮕ 로드밸런서로 HTTPS 요청이 와도 인스턴스(웹서버)에는 HTTP 프로토콜로 전달해 주어야 서버에서 클라이언트의 요청에 알맞는 응답 결과를 반환 할 수 있다.</p>\n</li>\n<li>\n<p>그러므로 HTTP/HTTPS 두 리스너는 모두 HTTP 80포트로 인스턴스 연결이 이뤄지게끔 타겟 대상을 설정 해주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144390493-66a4eb97-b839-49f0-b3d9-7715ef867dfd.png\" alt=\"스크린샷, 2021-12-02 18-00-00\"></p>\n<p>그리고 상태검사에서는 성공코드를 201번으로 변경하여 대상타겟을 생성해주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144390985-cc3aec51-cf97-4647-bc2a-5f207e2c4c53.png\" alt=\"스크린샷, 2021-12-02 18-02-42\"></p>\n</li>\n<li>\n<p>이제 로드밸런서가 외부 클라이언트로부터 HTTP/HTTPS 요청이 왔을 때 인스턴스로 이동하는 과정은 모두 완성하였다. 이제 인증서를 등록해 주어야 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144411410-47d3a10f-8b12-4c79-bd58-c97656cfec51.png\" alt=\"스크린샷, 2021-12-02 18-06-03\"></p>\n<p>HTTPS 프로토콜을 이용하려면 신뢰할 수 있는 기관에서 발급받은 인증서로 통해 통신이 이뤄진다. AWS에서는 ACM(<em>AWS에서 제공하는 인증서</em>)를 권장하고 있으며, 기존 사용하던 인증서가 있다면 해당 인증서를 import 해주어서 로드밸런서에 인증서를 등록해줄수도 있다.</p>\n<p>AWS에서도 무료로 인증서 발급을 해주기도하고, 권장하는 방법이기 때문에 새로 발급해서 사용하기로 하였다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-3-acm을-통한-인증서-발급\" style=\"position:relative;\"><a href=\"#1-3-acm%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\" aria-label=\"1 3 acm을 통한 인증서 발급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-3. ACM을 통한 인증서 발급</h4>\n<hr>\n<ul>\n<li>\n<p>AWS에서 발급 가능한 인증서를 만들기 위해 우선 <strong>새 인증서 요청</strong> 버튼으로 진입 후 요청을 눌러준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144416238-157f4c2d-0eaa-4374-b5c6-b2f9356992ff.png\" alt=\"스크린샷, 2021-12-02 20-46-27\"></p>\n<p>퍼블릭 인증서 요청을 선택한 뒤 다음 버튼을 누르면, 도메인 이름과 검증 방식을 설정해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144416552-6a6e340d-d5a2-4276-b512-c9f6a11330e0.png\" alt=\"스크린샷, 2021-12-02 20-48-33\"></p>\n<p>도메인 이름에 다른이름을 추가한 이유는 서버/클라이언트 각각 다른 도메인으로 배포하기 위함이다. (서버는 server.cmarket.cf 로 배포하였다.)</p>\n<p>Freenom에서 발급 받은 도메인 앞에 와일드카드(<code class=\"language-text\">*</code>)를 입력하여 도메인이름을 설정하였다.</p>\n<p>그리고 검증방식은 DNS 방식을 선택해주자. <del>(이게 간편하다고 하더라..)</del></p>\n</li>\n<li>\n<p>조금 기다린 뒤 인증서 ID를 눌러보면 CNAME 값이 생성된 것을 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143906637-868b596f-7209-491e-becf-7347fe2e9ffd.png\" alt=\"스크린샷, 2021-11-30 01-31-46\"></p>\n<p>그 뒤 Manage Freenom DNS 로 이동해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144420586-a718cd8f-3a36-4078-b4ca-49bcf92bc503.png\" alt=\"스크린샷, 2021-12-02 20-56-02\"></p>\n<blockquote>\n<p>AWS Route 53에서 발급받은 도메인이라면 레코드 추가하기로 간편하게 Route 53에서 DNS 검증이 가능하지만, 무료 도메인을 발급 받은 상황이기때문에 Freenom DNS로 가서 설정을 변경해줘야 한다.</p>\n</blockquote>\n<br>\n<br>\n</li>\n<li>\n<p>TYPE을 CNAME 으로 변경해 준 뒤, AWS에서 확인한 CNAME 이름과 값을 넣어주고 저장해준다.</p>\n<p>그 후 ACM으로 와서 검증이 끝날 때 까지(<em>5~10분정도 소요되었다.</em>) 기다려주면 아래와 같은 인증서 발급 완료 안내를 확인 할 수 있다.</p>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143908476-0a484866-aafa-4382-8d04-2099ea5ef71f.png\" alt=\"스크린샷, 2021-11-30 01-45-32\"></p>\n<ul>\n<li>생성 중이던 로드밸런서에 발급받은 인증서를 넣고 생성을 완료한다.</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-4-freenom--route-53-연결\" style=\"position:relative;\"><a href=\"#1-4-freenom--route-53-%EC%97%B0%EA%B2%B0\" aria-label=\"1 4 freenom  route 53 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-4. Freenom ⬌ Route 53 연결</h4>\n<hr>\n<br>\n<br>\n<h5 id=\"route-53란\" style=\"position:relative;\"><a href=\"#route-53%EB%9E%80\" aria-label=\"route 53란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Route 53란?</h5>\n<hr>\n<ul>\n<li>\n<p>우선 Route 53은 AWS에서 제공하는 DNS(Domain Name Service)이다.</p>\n<p>그 외에도 도메인과 관련된 여러가지 서비스를 제공한다. 간략히 DNS 개념만 언급하자면 IP로 도메인을 기억하기는 힘들기때문에 사람이 기억하기 이름 형태로 변환해주는 시스템이다.</p>\n</li>\n<li>\n<p>이제 Freenom DNS 검증은 완료되었다, AWS에서 해당 도메인을 사용하기 위해서 Freenom Nameservers 설정을 변경해 주자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143911244-7cb509e0-6b6a-4406-a120-eed04b5f6317.png\" alt=\"스크린샷, 2021-11-30 02-02-27\"></p>\n<p>위 사진 영역에 Route 53에서 호스팅 영역을 생성 후 NS 에 해당하는 라우팅 대상을 맵핑해서 넣어주면 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/143912771-bbaacb32-af5e-439c-9bfe-b2bcc58eabc6.png\" alt=\"스크린샷, 2021-11-30 02-13-28\"></p>\n</li>\n<li>\n<p>이제 Freenom에서 발급 받은 무료 도메인(cmarket.cf)은 AWS Certificate Manager을 받기 위한 DNS 검증도 끝났으며, Route 53 호스팅 영역에도 연결이 되었다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-5-route-53--elb-연결\" style=\"position:relative;\"><a href=\"#1-5-route-53--elb-%EC%97%B0%EA%B2%B0\" aria-label=\"1 5 route 53  elb 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-5. Route 53 ⬌ ELB 연결</h4>\n<hr>\n<ul>\n<li>\n<p>Route 53도 도메인과 연결되어 있으며 ELB도 인스턴스에 연결되어 있는 상태이다. 이 둘을 연결만 해주면 도메인에서도 인스턴스 접근이 가능하다.</p>\n<p>Route 53 메뉴로 가서 레코드 한줄만 써주도록 하자.</p>\n<p>서버를 도메인에 등록할텐데, 인증서 발급시 와일드카드(<code class=\"language-text\">*</code>)로 주었기 때문에 서버의 도메인은 원하는 이름을 주어도 가능하다.</p>\n<p>아래 사진과 같이 레코드를 생성해주었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144421521-15fd77de-474f-41dc-a80e-caeb95d46b3b.png\" alt=\"스크린샷, 2021-12-02 21-24-45\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"1-6-연결-확인\" style=\"position:relative;\"><a href=\"#1-6-%EC%97%B0%EA%B2%B0-%ED%99%95%EC%9D%B8\" aria-label=\"1 6 연결 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-6. 연결 확인</h4>\n<hr>\n<ul>\n<li>\n<p>이제 server.cmarket.cf 도메인을 브라우저 검색창에 검색한다면, AWS의 Route 53의 DNS서비스를 통하여 ELB에 접근하게된다.</p>\n<p>ELB에서는 트래픽을 자동으로 분산 시켜서 HTTPS/HTTP 을 요청을 리스너를 통하여 HTTP/80번 포트로 EC2 인스턴스 접근을 허용시킨다.</p>\n</li>\n<li>\n<p>EC2에 서버가 켜져있다면 endpoint <code class=\"language-text\">/</code> 로 접근이 될것이므로,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">201</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>따라서 <a href=\"https://server.cmarket.cf/\" target=\"_blank\"><a href=\"https://server.cmarket.cf\">https://server.cmarket.cf</a></a> 도메인 검색시 아래와 같은 결과가 확인된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144422316-8d6ed790-125f-4959-9243-dfc05ca6d63a.png\" alt=\"스크린샷, 2021-12-02 21-30-26\"></p>\n<p>해당 도메인에 AWS에서 발급받은 인증서가 유효하게 작동하는 HTTPS 서버 도메인이 완성되었다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h3 id=\"2-무료-도메인-https-aws-배포---프론트엔드\" style=\"position:relative;\"><a href=\"#2-%EB%AC%B4%EB%A3%8C-%EB%8F%84%EB%A9%94%EC%9D%B8-https-aws-%EB%B0%B0%ED%8F%AC---%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C\" aria-label=\"2 무료 도메인 https aws 배포   프론트엔드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 무료 도메인 HTTPS AWS 배포 - 프론트엔드</h3>\n<hr>\n<br>\n<br>\n<h4 id=\"2-1-s3-버킷-엔드포인트-수정\" style=\"position:relative;\"><a href=\"#2-1-s3-%EB%B2%84%ED%82%B7-%EC%97%94%EB%93%9C%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%88%98%EC%A0%95\" aria-label=\"2 1 s3 버킷 엔드포인트 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. S3 버킷 엔드포인트 수정</h4>\n<hr>\n<ul>\n<li>\n<p>기존 버킷에 등록된 빌드 파일은 HTTP로 서버와 클라이언트간 통신이 이뤄지고 있었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144423691-019196bd-2cbc-44cc-980a-ffbb4bcaf39b.png\" alt=\"스크린샷, 2021-12-02 17-51-26\"></p>\n<p>ACM을 이용한 HTTPS 인증방식이 이뤄질 수 있도록 클라이언트의 <code class=\"language-text\">.env</code> 파일을 수정하여 엔드포인트를 <a href=\"https://server.cmarket.cf\">https://server.cmarket.cf</a> 로 변경해 준 뒤 다시 빌드하여 버킷에 다시 업로드 해주었다.</p>\n</li>\n</ul>\n<h4 id=\"2-2-cloudfront-배포-생성-s3--cloudfront-연결\" style=\"position:relative;\"><a href=\"#2-2-cloudfront-%EB%B0%B0%ED%8F%AC-%EC%83%9D%EC%84%B1-s3--cloudfront-%EC%97%B0%EA%B2%B0\" aria-label=\"2 2 cloudfront 배포 생성 s3  cloudfront 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. CloudFront 배포 생성 (S3 ⬌ CloudFront 연결)</h4>\n<hr>\n<ul>\n<li>\n<p>버킷으로는 인증서를 이용한 HTTPS 인증방식이 불가능하기 때문에, S3를 CloudFront에 연결해 주어야 한다.</p>\n</li>\n<li>\n<p>우선 CloudFront 생성하기로 진입 후 원본 도메인에서 기존 S3 버킷을 선택해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144424581-a9dadcea-be3f-44b8-ae39-066b504c9c07.png\" alt=\"스크린샷, 2021-12-02 21-44-21\"></p>\n</li>\n<li>\n<p>기본 캐시동작에서 뷰어 프로토콜 정책은 Redirect HTTP to HTTPS 로 선택해 준다</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144424748-0520949f-381d-4a7f-85fb-de731eb71af1.png\" alt=\"스크린샷, 2021-12-02 21-44-42\"></p>\n</li>\n<li>\n<p>그 다음 설정에서 CNAME은 도메인으로 쓸 cmarket.cf를 입력 해 준뒤, 미리 생성해 둔 인증서(us-east-1)를 등록해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144425006-75cb095b-c14f-4952-9612-c23a98770d90.png\" alt=\"스크린샷, 2021-12-02 21-47-37\"></p>\n<p><strong>인증서는 반드시 미국 동부(버지니아 북부) 리전(us-east-1)에 있어야 합니다.</strong></p>\n<p><em>이 문구 때문에 사실 서울 리전을 한번 갈아 엎고 미국 동부 리전에서 다시 시작하였다…</em> <del>장난..??</del></p>\n<p>그리고 계속하여 설정에서 기본값 루트 객체를 index.html으로 수정해준 뒤 배포 생성을 완료해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144425488-f118043d-d44a-4f3b-9009-e2209377cf22.png\" alt=\"스크린샷, 2021-12-02 21-51-06\"></p>\n</li>\n<li>\n<p>그 뒤 배포 상태가 <strong>활성화 됨</strong>으로 확인되면, 배포 아이디 클릭 후 오류 페이지로 접근 하여 사용자 정의 오류 응답을 작성해 준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144425878-f7959699-d29e-4781-b084-deb136799673.png\" alt=\"스크린샷, 2021-12-02 21-53-28\"></p>\n<p>에러코드 403번과 404번 모두 오류 응답 200번 코드로 응답 페이지는 /index.html 으로 설정 해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144426098-da4a7eb7-7f6b-427a-9eeb-bf419f61a804.png\" alt=\"스크린샷, 2021-12-02 21-55-05\"></p>\n<p>이제 클라이언트도 유효한 인증서를 기반으로 HTTPS 인증방식으로 서버와 통신할 수 있게 배포가 되었다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"2-3-route-53--cloudfront-연결\" style=\"position:relative;\"><a href=\"#2-3-route-53--cloudfront-%EC%97%B0%EA%B2%B0\" aria-label=\"2 3 route 53  cloudfront 연결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. Route 53 ⬌ CloudFront 연결</h4>\n<hr>\n<ul>\n<li>\n<p>사실 Cloudfront 배포가 성공하였다면, AWS에서 제공하는 유효한 도메인이 발급이 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144426871-9e5f9d34-31d3-4d11-a8d1-983a157e2a38.png\" alt=\"스크린샷, 2021-12-02 22-00-11\"></p>\n<p>다만..<del>(이쁘지 않다..)</del> 애써 발급받은 도메인을 놀리기엔 아깝지 않은가? ELB를 도메인과 연결시켰듯이 클라이언트가 담긴 Cloudfront 또한 Route 53에서 별칭 레코드를 생성해주자.</p>\n</li>\n<li>\n<p>Route 53의 호스팅 영역으로 간뒤, 레코드 생성을 아래와 같이 해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144427560-b399fcf4-9bd4-43bd-b70c-c526445fc57b.png\" alt=\"스크린샷, 2021-12-02 22-03-59\"></p>\n<p>cmarket.cf 도메인 주소를 클라이언트가 보여지는 영역으로 쓸 것이므로 이름값은 따로 주지 않았다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h4 id=\"2-4-연결-확인\" style=\"position:relative;\"><a href=\"#2-4-%EC%97%B0%EA%B2%B0-%ED%99%95%EC%9D%B8\" aria-label=\"2 4 연결 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. 연결 확인</h4>\n<hr>\n<ul>\n<li>\n<p>이제 클라이언트/서버가 모두 HTTPS 인증방식으로 내가 원하는 도메인으로 발급이 모두 완료되었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144428894-aff7f1f8-2401-42aa-8298-8f79ad67dc4f.gif\" alt=\"cmarket cf\"></p>\n<p>리스너를 HTTP/HTTPS 방식 모두 지원하기 때문에 도메인에 배포한 HTTPS 방식의 통신도 지원하며, S3 버킷에서 HTTP 환경으로 클라이언트를 구동시켜도 모두 서버와 원활히 통신이 가능하다.</p>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<hr>\n<ul>\n<li>\n<p>AWS…너무 어렵다.</p>\n<p>단순히 인스턴스 올리고 버킷에 객체 업로드 하고 RDS로 DB 생성 후 연동하는건 정말 걸음마 단계였던거 같다.</p>\n</li>\n<li>\n<p>원래 해당 스프린트는 Advanced 과정으로 코드스테이츠에는 Route 53에서 도메인을 구매 후 진행하라 일러준다.</p>\n<p>학습과정에서 적게는 9$ 이상씩 지불하기가 아깝기도 하고.. AWS에서 지원하지 않는 외부 도메인을 사용해서 Route 53에서 등록하는 과정까지 학습과정에서는 모두 좋은 경험이라 생각든다.</p>\n</li>\n<li>\n<p>마음에 안드는 부분은 CloudFront 배포가 무조건 us-east-1 리전에서만 가능하기때문에 EC2 인스턴스도 억지로 서울 리전을 버리고 us-east-1 리전으로 강제 이주하였다..</p>\n<p>서두에 말했듯이, 미국지역 리전의 응답속도와 서울 리전의 응답속도는 하늘과 땅차이 였다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/144410348-669abeb7-67a6-413f-95bf-4e4373125150.png\" alt=\"스크린샷, 2021-12-02 19-54-25\"></p>\n<p>위와 같이 엄청난 속도차이가 있다.<del>(역시 인터넷 속도는 한국)</del> 서울 리전에 서버를 두고 다시 배포해보는 과정을 생각해봐야 겠다. (이렇게 되면 클라이언트/서버 각각 인증서가 리전이 다른데 유효할지 의문이 든다..)</p>\n<p>찜찜하지만.. 우선 초기에 목표로 둔 내가 원하는 도메인에 HTTPS 인증방식으로 배포하는게 성공해서 잠은 푹 잘 수 있을듯 하다.</p>\n</li>\n</ul>\n<br>\n<br>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li>\n<p><a href=\"#1-%EB%AC%B4%EB%A3%8C-%EB%8F%84%EB%A9%94%EC%9D%B8-https-aws-%EB%B0%B0%ED%8F%AC---%EB%B0%B1%EC%97%94%EB%93%9C\">1. 무료 도메인 HTTPS AWS 배포 - 백엔드</a></p>\n<ul>\n<li>\n<p><a href=\"#1-1-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%B0%9C%EA%B8%89\">1-1. 도메인 발급</a></p>\n</li>\n<li>\n<p><a href=\"#1-2-elb-%EC%83%9D%EC%84%B1\">1-2. ELB 생성</a></p>\n<ul>\n<li><a href=\"#elb%EB%9E%80\">ELB란?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#1-3-acm%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\">1-3. ACM을 통한 인증서 발급</a></p>\n</li>\n<li>\n<p><a href=\"#1-4-freenom--route-53-%EC%97%B0%EA%B2%B0\">1-4. Freenom ⬌ Route 53 연결</a></p>\n<ul>\n<li><a href=\"#route-53%EB%9E%80\">Route 53란?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#1-5-route-53--elb-%EC%97%B0%EA%B2%B0\">1-5. Route 53 ⬌ ELB 연결</a></p>\n</li>\n<li>\n<p><a href=\"#1-6-%EC%97%B0%EA%B2%B0-%ED%99%95%EC%9D%B8\">1-6. 연결 확인</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EB%AC%B4%EB%A3%8C-%EB%8F%84%EB%A9%94%EC%9D%B8-https-aws-%EB%B0%B0%ED%8F%AC---%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C\">2. 무료 도메인 HTTPS AWS 배포 - 프론트엔드</a></p>\n<ul>\n<li><a href=\"#2-1-s3-%EB%B2%84%ED%82%B7-%EC%97%94%EB%93%9C%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%88%98%EC%A0%95\">2-1. S3 버킷 엔드포인트 수정</a></li>\n<li><a href=\"#2-2-cloudfront-%EB%B0%B0%ED%8F%AC-%EC%83%9D%EC%84%B1-s3--cloudfront-%EC%97%B0%EA%B2%B0\">2-2. CloudFront 배포 생성 (S3 ⬌ CloudFront 연결)</a></li>\n<li><a href=\"#2-3-route-53--cloudfront-%EC%97%B0%EA%B2%B0\">2-3. Route 53 ⬌ CloudFront 연결</a></li>\n<li><a href=\"#2-4-%EC%97%B0%EA%B2%B0-%ED%99%95%EC%9D%B8\">2-4. 연결 확인</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 26, 2021","title":"무료 도메인 주소를 이용한 AWS HTTPS 인증","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2021-11-26-TIL/"}},"site":{"siteMetadata":{"siteUrl":"https://blog.jh8459.com","comments":{"utterances":{"repo":"JH8459/JH8459.github.io"}}}}},"pageContext":{"slug":"/2021-11-02-TIL/","nextSlug":"/2021-10-29-TIL/","prevSlug":"/2021-11-26-TIL/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}