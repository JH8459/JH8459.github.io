{"componentChunkName":"component---src-templates-blog-template-js","path":"/2022-05-25-TIL/","result":{"data":{"cur":{"id":"c21db44c-cac8-5fe1-84f1-b1a98333b5b7","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAID/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/2gAMAwEAAhADEAAAAdJomgf/xAAWEAADAAAAAAAAAAAAAAAAAAAAASD/2gAIAQEAAQUCFP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/AiL/AP/EABgQAAIDAAAAAAAAAAAAAAAAAAABESAx/9oACAEBAAE/IRm9hX//2gAMAwEAAgADAAAAEAw//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAIEFR/9oACAEBAAE/EI1YY7tf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/til.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/til.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/til.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/til.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/til.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/til.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<br>\n<ul>\n<li>\n<p>최근 NestJS + TypeORM 프레임워크로 서버를 구성하며 공부하고있다.</p>\n</li>\n<li>\n<p>TypeORM이 Repository Pattern을 기본으로 지향하고 지원하고 있으며 <a href=\"https://docs.nestjs.com/techniques/database#repository-pattern\" target=\"_blank\">NestJS 공식 문서</a>에도 Repository Pattern을 이용한 설계 방식을 안내하고 있다.</p>\n</li>\n<li>\n<p>나 또한 현재 진행 중인 프로젝트에 공식 문서를 읽고 Repository Pattern를 적용해서 개발을 이어나가고 있다.</p>\n</li>\n<li>\n<p>문득 Repository Pattern가 무엇이고 왜 쓰는거지? 가 궁금해졌고 그 과정을 글로 남겨보려한다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"1-repository-pattern\" style=\"position:relative;\"><a href=\"#1-repository-pattern\" aria-label=\"1 repository pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Repository Pattern</h3>\n<hr>\n<ul>\n<li>\n<p>우선 Repository Pattern은 여러 디자인 패턴 중 하나이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/170282459-fc4d1f03-ef48-485a-b009-f08abd3b915b.png\" alt=\"overview-1\"><br><br></p>\n</li>\n<li>\n<p>내가 이해한(?)대로 말하자면 실제 데이터가 있는 장소를 추상화하여 <strong>Repository</strong>로 둔 뒤, 해당 장소에서 데이터를 가져오고 가공하는 업무를 전담한다.</p>\n</li>\n<li>\n<p>그렇기에 클라이언트에서는 내가 원하는 데이터의 출처(Local, Remote)라던지, 원본 데이터 속성등을 알아야할 필요가 없다.</p>\n</li>\n<li>\n<p>그저 특정 요청을 <strong>Repository</strong>에 보내면 가공된 원하는 데이터 얻을 수 있게끔 디자인 패턴을 설계하는 구조가 <strong>Repository Pattern</strong>이다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"2-실제-프로젝트-적용-예시\" style=\"position:relative;\"><a href=\"#2-%EC%8B%A4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%81%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"2 실제 프로젝트 적용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 실제 프로젝트 적용 예시</h3>\n<hr>\n<ul>\n<li>\n<p>우선 NestJS 프레임워크 강의를 들으며 작성한 <strong>Repository Pattern</strong>이 적용된 샘플 코드를 가져왔다.</p>\n<ul>\n<li>\n<p><em>boards.service.ts</em></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">Injectable</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BoardsService</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\r\n    <span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">InjectRepository</span></span><span class=\"token punctuation\">(</span>BoardRepository<span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">private</span> boardRepository<span class=\"token operator\">:</span> BoardRepository<span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\r\n\r\n  <span class=\"token comment\">/* 전달인자로 CreateBoardDTO를 갖는 보드를 생성하는 createBoard 메서드 선언 */</span>\r\n  <span class=\"token function\">createBoard</span><span class=\"token punctuation\">(</span>createBoardDto<span class=\"token operator\">:</span> CreateBoardDto<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>Board<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>boardRepository<span class=\"token punctuation\">.</span><span class=\"token function\">createBoard</span><span class=\"token punctuation\">(</span>createBoardDto<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Repository 패턴 적용</span>\r\n  <span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token operator\">...</span></code></pre></div>\n</li>\n<li>\n<p><em>boards.repository.ts</em></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">/* Board Entity를 컨트롤하는 Repository를 선언 */</span>\r\n<span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">EntityRepository</span></span><span class=\"token punctuation\">(</span>Board<span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BoardRepository</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Repository<span class=\"token operator\">&lt;</span>Board<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token comment\">/* createBoard 메서드, DB 관련 동작은 Repository에서 수행한다 */</span>\r\n  <span class=\"token keyword\">async</span> <span class=\"token function\">createBoard</span><span class=\"token punctuation\">(</span>createBoardDto<span class=\"token operator\">:</span> CreateBoardDto<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>Board<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">/* title과 description은 구조분해 할당으로 createBoardDto에서 꺼내어서 사용해준다 */</span>\r\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> description <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> createBoardDto<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">const</span> board <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\r\n      title<span class=\"token punctuation\">,</span>\r\n      description<span class=\"token punctuation\">,</span>\r\n      status<span class=\"token operator\">:</span> BoardStatus<span class=\"token punctuation\">.</span><span class=\"token constant\">PUBLIC</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// status값은 BoardStatus.PUBLIC으로 초기화한다</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// board를 데이터베이스에 저장</span>\r\n    <span class=\"token keyword\">return</span> board<span class=\"token punctuation\">;</span> <span class=\"token comment\">// DB에 저장한 board를 반환한다</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>간단한 코드지만 <strong>Repository Pattern</strong>이 적용된 걸 볼 수 있다.</p>\n</li>\n<li>\n<p><strong>데이터를 원본 저장소에서 꺼내온 뒤 가공해서 제공하는 장소</strong>(boards.repository.ts)와 그 <strong>데이터를 사용하는 장소</strong>(boards.service.ts)를 분리시킨 디자인 패턴임을 알 수 있다.</p>\n</li>\n<li>\n<p>TypeORM에서 기본으로 Repository Pattern을 제공하기 때문에 위와 같은 디자인 패턴을 NestJS + TypeORM 프레임워크 생태계에서는 간단하게 구현할 수 있다는 장점이 있다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"3-repository-pattern의-장점\" style=\"position:relative;\"><a href=\"#3-repository-pattern%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"3 repository pattern의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Repository Pattern의 장점?</h3>\n<hr>\n<ul>\n<li>\n<p>우선 어떤 개념이고, 어떻게 쓰이는지는 알았으니 장점을 간단하게 찾아보았다.</p>\n<ul>\n<li>\n<p><strong>데이터 로직을 분리시킬 수 있다.</strong></p>\n<p>⇒ <em>파일 구조부터 분리가 된다.</em></p>\n</li>\n<li>\n<p><strong>중앙 집중처리 방식으로, 언제나 일관된 인터페이스로 데이터를 요청할 수 있다.</strong></p>\n<p>⇒ <em>요청을 하는 쪽은 Repository의 사정이 궁금하지도 필요하지도 않다. 언제나 항상 같은 인터페이스로 요청을하고 결과값을 제공받을 수 있다.</em></p>\n</li>\n<li>\n<p><strong>단위 테스트를 통해 검증이 가능합니다.</strong></p>\n<p>⇒ <em>테스트 경험은 없지만, 데이터를 가공하고 제공하는 Repository에서만 검증을 추가한다면 응답으로 반환될 데이터값들을 단위 테스트를 먼저 적용시켜 검증이 수월할 거 같다라는 생각은 든다.</em></p>\n</li>\n<li>\n<p><strong>새로운 데이터 로직 코드를 쉽게 추가할 수 있습니다.</strong></p>\n<p>⇒ <em>Repository에서만 코드를 추가하거나 수정하여 데이터 로직을 추가하거나 변경할 수 있으므로 큰 장점이다.</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<ul>\n<li>\n<p>그냥 NestJS 공식 문서에서 쓰라해서 썼고, TypeORM에서 기본으로 지원해주니 쓰던 Repository Pattern을 그나마 조금 이해하고 써 볼 수 있게 되었다.</p>\n</li>\n<li>\n<p>앞으로는 데이터를 가공하거나 가져오는 로직을 확실히 Repository 영역에서 수행해주는 쪽으로 조금 더 생각한 뒤 코드로 옮겨가야겠다~ 라는 생각이 들었다.</p>\n</li>\n</ul>\n<p>-규모가 큰 프로젝트일수록 디자인 패턴등 구조 설계부터 중요할거같다라는 생각이 든다.</p>\n<br>\r\n<br>","excerpt":"✍️ Today I Learned 최근 NestJS + TypeORM 프레임워크로 서버를 구성하며 공부하고있다. TypeORM이 Repository Pattern을 기본으로 지향하고 지원하고 있으며 NestJS 공식 문서에도 Repository Pattern을 이용한 설계 방식을 안내하고 있다. 나 또한 현재 진행 중인 프로젝트에 공식 문서를 읽고 Repository Pattern를 적용해서 개발을 이어나가고 있다. 문득 Repository Pattern가 무엇이고 왜 쓰는거지? 가 궁금해졌고 그 과정을 글로 남겨보려한다. 1. Repository Pattern 우선 Repository Pattern은 여러 디자인 패턴 중 하나이다. overview-1 내가 이해한(?)대로 말하자면 실제 데이터가 있는 장소를 추상화하여 Repository로 둔 뒤, 해당 장소에서 데이터를 가져오고 가공하는 업무를 전담한다. 그렇기에 클라이언트에서는 내가 원하는 데이터의 출처(Local, Remote…","timeToRead":2,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li><a href=\"#1-repository-pattern\">1. Repository Pattern</a></li>\n<li><a href=\"#2-%EC%8B%A4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%81%EC%9A%A9-%EC%98%88%EC%8B%9C\">2. 실제 프로젝트 적용 예시</a></li>\n<li><a href=\"#3-repository-pattern%EC%9D%98-%EC%9E%A5%EC%A0%90\">3. Repository Pattern의 장점?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>","frontmatter":{"date":"2022.05.25","title":"Repository Pattern","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-05-25-TIL/"}},"next":{"id":"6f773290-20af-50f8-81a1-4c28227d1aac","frontmatter":{"date":"2022.05.06","title":"NestJS + 가비아 메시징 API 개발 가이드","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-05-06-TIL/"}},"prev":{"id":"fe5b9c82-a0c0-59d3-83cb-2eb1de9d9d95","frontmatter":{"date":"2022.06.24","title":"NestJS DTO vs Interface","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-06-24-TIL/"}},"site":{"siteMetadata":{"siteUrl":"https://blog.jh8459.com","comments":{"giscus":{"repo":"JH8459/JH8459.github.io","repoId":"R_kgDOI03HgA","category":"Comments","categoryId":"DIC_kwDOI03HgM4CtuXL"}}}}},"pageContext":{"slug":"/2022-05-25-TIL/","nextSlug":"/2022-05-06-TIL/","prevSlug":"/2022-06-24-TIL/"}},"staticQueryHashes":["1073350324","2009502679","2938748437","962130685"],"slicesMap":{}}