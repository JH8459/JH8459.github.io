{"componentChunkName":"component---src-templates-blog-template-js","path":"/2022-06-24-TIL/","result":{"data":{"cur":{"id":"7baa32a5-412b-5d17-975f-e5790a50c130","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAID/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/2gAMAwEAAhADEAAAAdJomgf/xAAWEAADAAAAAAAAAAAAAAAAAAAAASD/2gAIAQEAAQUCFP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/AiL/AP/EABgQAAIDAAAAAAAAAAAAAAAAAAABESAx/9oACAEBAAE/IRm9hX//2gAMAwEAAgADAAAAEEw//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAIEFR/9oACAEBAAE/EI1YY7tf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/TIL.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/TIL.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/TIL.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/TIL.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<br>\n<ul>\n<li>\n<p>TypeScript를 기본 언어로 채택하여 구성된 NestJS 프레임워크는 공식문서에서는 Type Check를 위해 <code class=\"language-text\">DTO</code> 사용을 안내하고 있다.</p>\n</li>\n<li>\n<p>공식문서를 토대로 <code class=\"language-text\">DTO</code>를 왜 사용하는지 찾아보는 그 과정에서 <code class=\"language-text\">Interface</code>와의 차이점을 간단히 알아보았다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"1-dto-data-transfer-object\" style=\"position:relative;\"><a href=\"#1-dto-data-transfer-object\" aria-label=\"1 dto data transfer object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. DTO (Data Transfer Object)</h3>\n<hr>\n<ul>\n<li>\n<p>우선 <code class=\"language-text\">DTO</code>란 **계층***간 데이터 교환을 위해 사용하는 객체이다.</p>\n<blockquote>\n<p>계층이란?</p>\n<p>패턴마다 다르게 표현된다.</p>\n<p>Repository 패턴에서는 Controller, Service, Repository를 각각 계층이라 칭하며, MVC 패턴에서는 Model, View, Controller의 계층이 존재한다.</p>\n</blockquote>\n</li>\n<li>\n<p>계층간 데이터를 주고 받을 때 어떤 모양의 데이터 객체로 주고 받을지를 <code class=\"language-text\">DTO</code>에서 결정하게 되므로 프로젝트를 설계할때 최우선으로 고려되야 할 요소이다.</p>\n</li>\n<li>\n<p>쉽게 말하자면 정보를 교환하는데 있어 타입을 체크하기 위한 구조라 설명할 수 있다.</p>\n</li>\n<li>\n<p>또한, 타입을 체크하기 위한 방법으로 <code class=\"language-text\">DTO</code>외에 <code class=\"language-text\">Interface</code>가 존재하며 이는 아래에서 다시 설명하겠다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"2-interface\" style=\"position:relative;\"><a href=\"#2-interface\" aria-label=\"2 interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Interface</h3>\n<hr>\n<ul>\n<li>\n<p>간단하게 설명하자면 인터페이스는 TypeScript에서 변수, 함수, 클래스의 타입 체크를 위해 사용되며 보기에는 클래스와 유사하지만 인스턴스 생성이 불가능하고 모든 메소드는 추상 메소드로 이루어져 있다.</p>\n</li>\n<li>\n<p>또한 <strong>“ES6에서 지원하지 않고 TypeScript에서만 지원한다.”</strong></p>\n</li>\n<li>\n<p>데이터 타입을 체크하기 위한 기능적인 면모로써는 <code class=\"language-text\">DTO</code>와 동일하지만 위에서 강조한것 처럼 ES6에서는 지원하지 않는다는 차이점이 있다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"3-why-dto\" style=\"position:relative;\"><a href=\"#3-why-dto\" aria-label=\"3 why dto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Why DTO?</h3>\n<hr>\n<ul>\n<li>\n<p>위 질문의 해답은 NestJS <a href=\"https://docs.nestjs.com/controllers#request-object\" target=\"_blank\">공식문서</a>(Request payloads 부분)에서는 왜 DTO로 안내하는지 설명이 자세히 안내되어 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/83164003/175549009-f7cb3010-f861-4750-a5e9-15978b486734.png\" alt=\"스크린샷 2022-06-24 오후 10 11 12\"></p>\n<p>위 내용을 위 <code class=\"language-text\">Interface</code>를 설명했던 내용과 덧붙혀 간략히 줄이자면 TypeScript의 클래스는 JavaScript ES6 표준을 따르므로 TypeScript로 작성되었지만 컴파일 된 JavaScript에서는 인터페이스는 컴파일 도중 제거되므로(<code class=\"language-text\">Interface</code>는 ES6 표준이 아니므로) NestJS에서 런타임에 인터페이스를 참조할 수 없게된다.</p>\n</li>\n<li>\n<p>따라서 NestJS에서는 런타임 이후 <code class=\"language-text\">Input</code>값에 대한 유효성 검증이라던지 그 외의 데이터 타입을 지속적으로 추적해야하는 경우 <code class=\"language-text\">DTO</code>는 Class로 작성되기에 ES6 표준이므로 참조가 가능 하지만, <code class=\"language-text\">Interface</code>는 ES6 표준 문법이 아니므로 제거되기에 참조할 수 없게된다.</p>\n</li>\n</ul>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<ul>\n<li>\n<p>그냥 학습한 대로 습관적으로 <code class=\"language-text\">DTO</code>를 사용하다 불현듯 떠오른 궁금증인 <strong>“클래스 문법으로 생성되지만 인스턴스를 생성하는 것도 아니고.. 단순 타입 검증만을 위해 사용되는게 아닌가? 그럼 인터페이스랑 다른게 무엇이지?”</strong> 라는 의문점에서 찾아보니 이와같은 결론에 도달하게 되었다.</p>\n</li>\n<li>\n<p>NestJS 공식 문서는 대단하다.</p>\n<p>모든 궁금증에 대한 내용이 이미 모두 기재되어 있었다. <del>(내가 찾아보질 않았을 뿐…)</del></p>\n</li>\n<li>\n<p>지금은 프로젝트 한창이라 너무 바쁘고, 어느정도 안정되면 공식문서 정주행을 한번 해야겠다.</p>\n</li>\n</ul>\n<br>\r\n<br>","excerpt":"✍️ Today I Learned TypeScript를 기본 언어로 채택하여 구성된 NestJS 프레임워크는 공식문서에서는 Type Check를 위해  사용을 안내하고 있다. 공식문서를 토대로 를 왜 사용하는지 찾아보는 그 과정에서 와의 차이점을 간단히 알아보았다. 1. DTO (Data Transfer Object) 우선 란 **계층***간 데이터 교환을 위해 사용하는 객체이다. 계층이란? 패턴마다 다르게 표현된다. Repository 패턴에서는 Controller, Service, Repository를 각각 계층이라 칭하며, MVC 패턴에서는 Model, View, Controller의 계층이 존재한다. 계층간 데이터를 주고 받을 때 어떤 모양의 데이터 객체로 주고 받을지를 에서 결정하게 되므로 프로젝트를 설계할때 최우선으로 고려되야 할 요소이다. 쉽게 말하자면 정보를 교환하는데 있어 타입을 체크하기 위한 구조라 설명할 수 있다. 또한, 타입을 체크하기 위한 방법으로 외에 가 존…","timeToRead":1,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li><a href=\"#1-dto-data-transfer-object\">1. DTO (Data Transfer Object)</a></li>\n<li><a href=\"#2-interface\">2. Interface</a></li>\n<li><a href=\"#3-why-dto\">3. Why DTO?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>","frontmatter":{"date":"2022.06.24","title":"NestJS DTO vs Interface","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-06-24-TIL/"}},"next":{"id":"90b62bb9-ae90-554e-bc54-f3a560c56afc","frontmatter":{"date":"2022.05.25","title":"Repository Pattern","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-05-25-TIL/"}},"prev":{"id":"284e9881-88e5-5c21-97e9-5e26d2e3ebd2","frontmatter":{"date":"2022.07.01","title":"Docker?","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2022-07-01-TIL/"}},"site":{"siteMetadata":{"comments":{"giscus":{"repo":"JH8459/JH8459.github.io","repoId":"R_kgDOI03HgA","category":"Comments","categoryId":"DIC_kwDOI03HgM4CtuXL"}}}}},"pageContext":{"slug":"/2022-06-24-TIL/","nextSlug":"/2022-05-25-TIL/","prevSlug":"/2022-07-01-TIL/"}},"staticQueryHashes":["1073350324","2009502679","2938748437","962130685"],"slicesMap":{}}