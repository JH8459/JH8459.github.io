{"componentChunkName":"component---src-templates-blog-template-js","path":"/2025-03-19-TIL/","result":{"data":{"cur":{"id":"45a5dca2-a8e0-5043-b4f4-936e507bb529","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAID/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/2gAMAwEAAhADEAAAAdJomgf/xAAWEAADAAAAAAAAAAAAAAAAAAAAASD/2gAIAQEAAQUCFP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/AiL/AP/EABgQAAIDAAAAAAAAAAAAAAAAAAABESAx/9oACAEBAAE/IRm9hX//2gAMAwEAAgADAAAAEEw//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAIEFR/9oACAEBAAE/EI1YY7tf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github-blog.png\"\n        title=\"\"\n        src=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg\"\n        srcset=\"/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/4ec73/TIL.jpg 180w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/158ba/TIL.jpg 360w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/80e3c/TIL.jpg 720w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/47311/TIL.jpg 1080w,\n/static/7c4bbfe7d1a9d6bc02891c94bfe039dc/ac614/TIL.jpg 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h2 id=\"️-today-i-learned\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-today-i-learned\" aria-label=\"️ today i learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</h2>\n<p><code class=\"language-text\">Docker</code> 파일을 작성할 때 습관처럼 큰 의심없이 아래와 같이 작성하곤한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\r\n<span class=\"token comment\"># 3단계: 빌드</span>\r\nRUN npm run build\r\n\r\nCMD <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"./dist/main.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p><code class=\"language-text\">package.json</code>에 별다른 설정을 안해두었다면 아래와 같을꺼라 <strong>npm run start:prod</strong> 명령과 같은 명령어이지만 습관(?)처럼 <code class=\"language-text\">Dockerfile</code>을 작성할 땐 “./dist/main.js”를 직접 실행시키고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n  ...\r\n  <span class=\"token property\">\"start:prod\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node dist/main\"</span><span class=\"token punctuation\">,</span>\r\n  ...</code></pre></div>\n<br>\r\n<br>\n<p>프레임워크에서 기본으로 제공하는 <strong>nest start</strong> CLI 명령어 또한 서버를 구동시키는 명령어인데, 빌드된 .js 파일을 직접 실행시키는 것과 어떤 차이가 있을지 궁금해서 찾아본 결과를 간략히 남기려한다.</p>\n<br>\r\n<br>\n<h3 id=\"1-눈에-띄는-차이점은\" style=\"position:relative;\"><a href=\"#1-%EB%88%88%EC%97%90-%EB%9D%84%EB%8A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\" aria-label=\"1 눈에 띄는 차이점은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 눈에 띄는 차이점은?</h3>\n<hr>\n<p>사실 입사 초기에 로컬 환경에서 쓰던 <code class=\"language-text\">Docker</code> 파일이 그대로 운영 환경<del>(심지어 —watch 옵션까지)</del>까지 이어진 경험이 있어서 Nest CLI 명령어는 어떤 사이드 이펙트를 발생시키는지 이미 몸소 체험해본적이 있다. 🥲</p>\n<p>간단히 같은 코드 베이스로 Nest CLI 명령어와 빌드된 .js 파일을 직접 실행한 환경으로 나누어서 컨테이너를 실행해보면 아래와 같이 눈으로도 확인이 가능할만한 차이점을 보이는 결과를 얻을 수 있다.</p>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-03-19-TIL/Initial.png\">\n<center>Nest CLI로 \"nest start\"로 실행한 컨테이너는 초기화 과정에서 CPU 점유율도 엄청나다 😲</center><br><br>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-03-19-TIL/Stabilization.png\">\n<center>초기화 과정 이후에도 메모리 점유율이 2배가 넘게 차이가 난다.</center><br><br>\n<p>유의미한 성능 차이가 존재한다는 점은 알고 있었으나 생각했었던 수치보다 더 크게 벌어진걸 눈으로 직접보니 놀라웠다.</p>\n<br>\r\n<br>\n<h3 id=\"2-nest-cli\" style=\"position:relative;\"><a href=\"#2-nest-cli\" aria-label=\"2 nest cli permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Nest CLI</h3>\n<hr>\n<p>왜 이런 큰 성능 차이를 보이는지는 Nest CLI의 actions에 정의된 <code class=\"language-text\">start.action.ts</code> 파일을 뜯어보면 알 수 있다.</p>\n<blockquote>\n<p><a href=\"https://github.com/nestjs/nest-cli/blob/c152351bba98b0562958b0d0223b7636c0183cb3/actions/start.action.ts#L17\" target=\"_blank\">nest-cli/actions/start.action.ts</a></p>\n</blockquote>\n<br>\r\n<br>\n<p>Nest CLI 명령으로 실행한 어플리케이션의 성능 저하 포인트들을 요약하자면 아래와 같다.</p>\n<ol>\n<li>\n<p>NestJS 설정 파일 로드</p>\n<ul>\n<li>\n<p><strong>commandOptions</strong>에서 config 옵션을 찾고, 이를 기반으로 <strong>this.loader.load(configFileName)</strong>을 호출하여 <code class=\"language-text\">nestjs-cli.json</code> 파일을 로드한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"$schema\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://json.schemastore.org/nest-cli\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"collection\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@nestjs/schematics\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"sourceRoot\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"src\"</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>TS 컴파일러 설정 로드</p>\n<ul>\n<li>\n<p><strong>getTscConfigPath()</strong>를 통해 <code class=\"language-text\">tsconfig.json</code> 경로를 찾고, JSON 값을 파싱한 결과 중 outDir 값을 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token property\">\"module\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"commonjs\"</span><span class=\"token punctuation\">,</span>\r\n    ...\r\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span><span class=\"token punctuation\">,</span>\r\n    ...\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>빌드 및 실행</p>\n<ul>\n<li>\n<p><strong>BuildAction.runBuild()</strong>가 실행되며 TypeScript를 빌드한다.</p>\n</li>\n<li>\n<p>빌드 후 <strong>createOnSuccessHook()</strong>이 실행되며 애플리케이션이 실행된다.</p>\n<ul>\n<li><strong>spawnChildProcess()</strong>를 통해 <strong>child_process.spawn()</strong>을 사용하여 새로운 프로세스로 감싸서 애플리케이션을 실행한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<br>\r\n<br>\n<p>즉, Nest CLI 명령어로 애플리케이션을 실행하면 여러 설정 파일들을 로드하며 새로이 빌드한 결과물을 새로운 프로세서로 감싸서 실행하고 있는 상황이다.</p>\n<br>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th><strong>“nest start”</strong></th>\n<th><strong>“node dist/main.js”</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>설정 파일 로드</strong></td>\n<td>Nest CLI 설정 파일 (<code class=\"language-text\">nest-cli.json</code>)을 로드함</td>\n<td>설정 파일을 로드하지 않음</td>\n</tr>\n<tr>\n<td><strong>빌드 과정</strong></td>\n<td>TS 설정 파일(<code class=\"language-text\">tsconfig.json</code>)로 TypeScript 빌드</td>\n<td>이미 빌드된 JS 파일 실행</td>\n</tr>\n<tr>\n<td><strong>프로세스 관리</strong></td>\n<td><strong>spawnChildProcess()</strong>를 통해 별도 프로세스를 생성</td>\n<td><strong>node</strong> 프로세스를 직접 실행</td>\n</tr>\n<tr>\n<td><strong>옵션</strong></td>\n<td><code class=\"language-text\">--watch</code> 옵션 지원 (핫 리로드)</td>\n<td>없음</td>\n</tr>\n</tbody>\n</table>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<p>습관처럼 사용하고 있었던 명령어들을 이젠 어떠한 이유로 인해 사용 해야하는지 알고 쓸 수 있게 되었다.</p>\n<p>Nest CLI 명령어는 여러 개발 편의 옵션들을 지원 하고 별도의 빌드 과정없이 빠른 실행을 가능하게 한다는 점은 알고 있었지만, 세부적인 코드 흐름을 눈으로 보니 왜 초기화 단계에서 왜 높은 CPU 사용량과 메모리 점유율을 보이는지 이해할 수 있었다.</p>\n<br>\r\n<br>","excerpt":"✍️ Today I Learned  파일을 작성할 때 습관처럼 큰 의심없이 아래와 같이 작성하곤한다. 에 별다른 설정을 안해두었다면 아래와 같을꺼라 npm run start:prod 명령과 같은 명령어이지만 습관(?)처럼 을 작성할 땐 “./dist/main.js”를 직접 실행시키고 있다. 프레임워크에서 기본으로 제공하는 nest start CLI 명령어 또한 서버를 구동시키는 명령어인데, 빌드된 .js 파일을 직접 실행시키는 것과 어떤 차이가 있을지 궁금해서 찾아본 결과를 간략히 남기려한다. 1. 눈에 띄는 차이점은? 사실 입사 초기에 로컬 환경에서 쓰던  파일이 그대로 운영 환경(심지어 —watch 옵션까지)까지 이어진 경험이 있어서 Nest CLI 명령어는 어떤 사이드 이펙트를 발생시키는지 이미 몸소 체험해본적이 있다. 🥲 간단히 같은 코드 베이스로 Nest CLI 명령어와 빌드된 .js 파일을 직접 실행한 환경으로 나누어서 컨테이너를 실행해보면 아래와 같이 눈으로도 확인이 가…","timeToRead":2,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-today-i-learned\">✍️ <strong>T</strong>oday <strong>I</strong> <strong>L</strong>earned</a></p>\n<ul>\n<li><a href=\"#1-%EB%88%88%EC%97%90-%EB%9D%84%EB%8A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\">1. 눈에 띄는 차이점은?</a></li>\n<li><a href=\"#2-nest-cli\">2. Nest CLI</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>","frontmatter":{"date":"2025.03.19","title":"Nest CLI 뜯어보기 (nest start)","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-03-19-TIL/"}},"next":{"id":"4983688a-4820-558e-92d7-4c7a61b27d16","frontmatter":{"date":"2025.03.16","title":"Docker Compose와 Traefik을 활용한 Blue/Green 배포 전략","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-03-16-TIL/"}},"prev":{"id":"339c4b95-e05a-5ddc-8f1f-eb9e6ff88faf","frontmatter":{"date":"2025.03.31","title":"EC2에서 NAS로, 개인 서버 CI/CD 자동화","categories":"Project","author":"JH8459","emoji":"🔥"},"fields":{"slug":"/2025-03-31-PROJECT/"}},"site":{"siteMetadata":{"comments":{"giscus":{"repo":"JH8459/JH8459.github.io","repoId":"R_kgDOI03HgA","category":"Comments","categoryId":"DIC_kwDOI03HgM4CtuXL"}}}}},"pageContext":{"slug":"/2025-03-19-TIL/","nextSlug":"/2025-03-16-TIL/","prevSlug":"/2025-03-31-PROJECT/"}},"staticQueryHashes":["1073350324","2009502679","2938748437","962130685"],"slicesMap":{}}