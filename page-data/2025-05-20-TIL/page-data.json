{"componentChunkName":"component---src-templates-blog-template-js","path":"/2025-05-20-TIL/","result":{"data":{"cur":{"id":"098ec7c0-56dd-5c16-b3bf-0ff4843f886b","html":"<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-05-20-TIL/thumbnail.png\">\n<br>\n<h2 id=\"통합-모니터링-환경-구축기\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%EA%B8%B0\" aria-label=\"통합 모니터링 환경 구축기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통합 모니터링 환경 구축기</h2>\n<p>이전 포스팅 중 AWS EC2에서 개인 서버로 마이그레이션을 진행한 과정을 소개한적이 있다.</p>\n<blockquote>\n<p><a href=\"https://blog.jh8459.com/2025-03-31-PROJECT/\">📌 EC2에서 NAS로, 개인 서버 CI/CD 자동화</a>에서는 EC2 환경에서 Synology NAS로 이전하며 개인 서버에 어플리케이션을 마이그레이션한 경험을 작성했다.</p>\n</blockquote>\n<br/>\n<p>하지만 마이그레이션 이후 AWS에서 기본으로 제공되던 CloudWatch와 같은 모니터링 도구들이 사라지면서 시스템이 정상적으로 동작하고 있는지, 리소스는 충분한지, 예기치 못한 에러가 발생하고 있진 않은지를 실시간으로 파악할 수 없게되었다.</p>\n<p>단순히 “배포되었다”는 사실만으로는 서비스의 안정성을 보장할 수 없다는 것을 다시금 실감했고 직접 모니터링 시스템을 구축해야 한다는 필요성이 명확해졌다.</p>\n<p>이번 포스팅에서는 <strong>Grafana + Prometheus + Loki</strong> 스택을 기반으로 여러 서버가 존재하는 사내 환경에서는 어떻게 모니터링 시스템을 구성했는지, 반대로 단일 서버에 여러 네트워크가 존재하는 NAS 환경에서는 어떤 방식으로 적용했는지 그리고 각 환경에서 사용된 에이전트들의 구성 방식과 차이점은 무엇이었는지를 기록으로 남겨보려 한다.</p>\n<br>\r\n<br>\n<h3 id=\"1-여러대의-서버-통합-모니터링\" style=\"position:relative;\"><a href=\"#1-%EC%97%AC%EB%9F%AC%EB%8C%80%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%86%B5%ED%95%A9-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-label=\"1 여러대의 서버 통합 모니터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 여러대의 서버 통합 모니터링</h3>\n<hr>\n<p>내가 속한 조직은 인프라를 온프레미스 기반으로 운영하고 있었고 여러 대의 Linux 서버에 다양한 서비스가 분산되어 실행되고 있었다. 하지만 분산된 서비스의 수가 많아질수록 서버마다 개별적으로 리소스나 로그 상태를 확인하는 방식에는 한계가 분명했다.</p>\n<ul>\n<li>어떤 서버의 리소스가 과부하인지 직관적으로 파악하기 어렵다.</li>\n<li>특정 시간대에 발생한 장애나 예외 로그를 서버별로 일일이 확인해야 한다.</li>\n<li>모니터링 방식이 서버 수에 비례해 관리 비용도 함께 늘어난다.</li>\n</ul>\n<br>\n<p>이 문제를 해결하기 위해 각 Linux 서버에 다음과 같은 <strong>Agent</strong>를 설치하고 중앙에서 수집하는 방식을 채택했다.</p>\n<ul>\n<li><code class=\"language-text\">node_exporter</code>: 시스템의 CPU, Memory, Disk 등 자원 정보를 수집</li>\n<li><code class=\"language-text\">cadvisor</code>: Docker 기반 컨테이너의 상태를 메트릭 단위로 수집</li>\n<li><code class=\"language-text\">mysql_exporter</code>: 데이터베이스 연결 수, 쿼리 처리량 등의 성능 정보 수집</li>\n<li><code class=\"language-text\">promtail</code>: 컨테이너 내부 로그를 Loki에 전송</li>\n</ul>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-05-20-TIL/idc.jpg\">\n<center>IDC에 Linux 서버가 추가되더라도 손쉽게 확장가능하다. 👍</center>\r\n<br><br>\n<p>각 서버는 Grafana + Prometheus + Loki를 실행하고 있는 서버와 동일한 네트워크(Private Networ)로 구성되어 있으므로 결과적으로 모든 서버의 상태와 중요 서비스들의 로그와 <strong>메트릭(metric)</strong>* 들을 하나의 Grafana 대시보드에서 확인할 수 있는 통합 모니터링 환경을 완성할 수 있었다.</p>\n<br>\n<blockquote>\n<p>📊 메트릭이란?</p>\n<p>메트릭(metric)은 시스템이나 애플리케이션의 상태를 숫자 형태로 표현한 시간열 데이터(time-series data)를 의미한다.\r\n예를 들어 CPU 사용률, 메모리 사용량, 네트워크 트래픽처럼 시간에 따라 변화하는 값들을 주기적으로 수집한 것이 메트릭에 포함된다.</p>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"2-단일-서버-모니터링\" style=\"position:relative;\"><a href=\"#2-%EB%8B%A8%EC%9D%BC-%EC%84%9C%EB%B2%84-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-label=\"2 단일 서버 모니터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 단일 서버 모니터링</h3>\n<hr>\n<p>반면 개인 프로젝트들은 NAS 한 대 위에 여러 개의 Docker 기반 프로젝트를 올려 운영하기 때문에 컨테이너 간 네트워크 구성과 모니터링 방식에 대해 많은 고민이 필요했다.</p>\n<p>특히, 하나의 서버 안에서 모든 컨테이너의 리소스와 로그를 통합 대시보드로 집계하려면 <strong>Agent</strong>마다 다른 수집 방식을 먼저 이해해야 했다.</p>\n<p>예를 들어 <code class=\"language-text\">mysqld-exporter</code>는 DB 내부에 직접 TCP 연결을 시도하는 방식으로 동작한다. 이 구조에서는 Agent와 DB 컨테이너가 동일한 Docker 네트워크에 존재하지 않으면 정상적인 수집이 불가능하다.</p>\n<blockquote>\n<p>이로 인해 해당 Agent는 <code class=\"language-text\">monitoring_network</code>와 <code class=\"language-text\">lottery_network</code> 두 네트워크에 모두 연결해야만 정상적으로 작동했다.</p>\n</blockquote>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-05-20-TIL/nas.jpg\">\n<center><strong>mysql-exporter</strong>는 두 네트워크에 모두 편입되어야한다.</center>\r\n<br><br>\n<p>반면, <code class=\"language-text\">cadvisor</code>나 <code class=\"language-text\">promtail</code>은 컨테이너 내부 접속 없이도 데이터를 수집할 수 있다. 이들은 네트워크 연결이 아니라 NAS 자체의 파일 시스템과 Docker 소켓을 마운트하는 방식으로 동작한다. 즉, 컨테이너의 리소스 사용량이나 로그를 직접 읽어오기만 하면 되기 때문에 별도의 네트워크 설정 없이도 모든 컨테이너를 관측할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># volumes을 마운트하여 모든 컨테이너의 리소스와 로그를 수집</span>\r\n<span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\r\n  <span class=\"token punctuation\">-</span> /<span class=\"token punctuation\">:</span>/rootfs<span class=\"token punctuation\">:</span>ro\r\n  <span class=\"token punctuation\">-</span> /var/run/docker.sock<span class=\"token punctuation\">:</span>/var/run/docker.sock<span class=\"token punctuation\">:</span>ro\r\n  <span class=\"token punctuation\">-</span> /var/lib/docker/<span class=\"token punctuation\">:</span>/var/lib/docker<span class=\"token punctuation\">:</span>ro</code></pre></div>\n<br>\n<p>이처럼 Agent마다 수집 방식이 다르기 때문에 단일 서버라고 해서 무조건 단순하게 구성할 수 있는 건 아니었다. 네트워크 기반 수집이 필요한 Agent는 네트워크 설계가 필요하고, 호스트 기반 수집이 가능한 Agent는 적절한 볼륨 마운트가 필요하다.</p>\n<p>이러한 구조적 이해를 바탕으로, NAS 환경에서도 Grafana 대시보드 하나로 모든 컨테이너 상태를 모니터링할 수 있는 환경을 완성할 수 있었다.</p>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<p>개인 프로젝트에 사용한 모니터링 도구들의 자세한 코드 구성이나 <code class=\"language-text\">docker-compose.yml</code> 파일은 <a href=\"https://github.com/JH8459/MONITORING-STACK\" target=\"_blank\">Github 링크</a>로 대체하겠다.</p>\n<p>이번 포스팅에서는 보유한 자원(Linux 서버가 여러대인지 혹은 단일 서버 구성인지)에 따라 어떻게 모니터링 시스템을 구성해야하는지에 대해 고민한 흔적을 공유해보고자 포스팅을 남긴다.</p>\n<br>\r\n<br>\n<div class=\"gatsby-highlight\" data-language=\"toc\"><pre class=\"language-toc\"><code class=\"language-toc\"></code></pre></div>","excerpt":"통합 모니터링 환경 구축기 이전 포스팅 중 AWS EC2에서 개인 서버로 마이그레이션을 진행한 과정을 소개한적이 있다. 📌 EC2에서 NAS로, 개인 서버 CI/CD 자동화에서는 EC2 환경에서 Synology NAS로 이전하며 개인 서버에 어플리케이션을 마이그레이션한 경험을 작성했다. 하지만 마이그레이션 이후 AWS에서 기본으로 제공되던 CloudWatch와 같은 모니터링 도구들이 사라지면서 시스템이 정상적으로 동작하고 있는지, 리소스는 충분한지, 예기치 못한 에러가 발생하고 있진 않은지를 실시간으로 파악할 수 없게되었다. 단순히 “배포되었다”는 사실만으로는 서비스의 안정성을 보장할 수 없다는 것을 다시금 실감했고 직접 모니터링 시스템을 구축해야 한다는 필요성이 명확해졌다. 이번 포스팅에서는 Grafana + Prometheus + Loki 스택을 기반으로 여러 서버가 존재하는 사내 환경에서는 어떻게 모니터링 시스템을 구성했는지, 반대로 단일 서버에 여러 네트워크가 존재하는 NA…","timeToRead":2,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%86%B5%ED%95%A9-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%EA%B8%B0\">통합 모니터링 환경 구축기</a></p>\n<ul>\n<li><a href=\"#1-%EC%97%AC%EB%9F%AC%EB%8C%80%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%86%B5%ED%95%A9-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\">1. 여러대의 서버 통합 모니터링</a></li>\n<li><a href=\"#2-%EB%8B%A8%EC%9D%BC-%EC%84%9C%EB%B2%84-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\">2. 단일 서버 모니터링</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>","frontmatter":{"date":"2025.05.20","title":"Grafana + Prometheus + Loki 환경에서 Agents는 어떻게 설계해야 할까?","categories":"TIL","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-05-20-TIL/"}},"next":{"id":"df72ad6e-8bde-5e71-bee8-f3d9375b3382","html":"<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-04-29-PROJECT/thumbnail.png\">\n<br>\n<h2 id=\"e2e-테스트-설계와-테스트-자동화\" style=\"position:relative;\"><a href=\"#e2e-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%84%A4%EA%B3%84%EC%99%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%8F%99%ED%99%94\" aria-label=\"e2e 테스트 설계와 테스트 자동화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>E2E 테스트 설계와 테스트 자동화</h2>\n<p>이전 포스팅 중 개인 서버에 CI/CD 구축한 과정을 소개한적이 있다.</p>\n<blockquote>\n<p><a href=\"https://blog.jh8459.com/2025-03-31-PROJECT/\">EC2에서 NAS로, 개인 서버 CI/CD 자동화</a>에서는 EC2 환경에서 Synology NAS로 이전하며 개인 서버에서도 CI/CD 파이프라인을 자동화한 과정을 공유했었다.</p>\n</blockquote>\n<br/>\n<p>하지만 변경된 코드가 정상적으로 동작하는지를 보장하지 못한다면 빌드·배포의 자동화는 그 의미가 많이 퇴색된다 생각한다. <strong>(새로 배포된 코드로 인해 장애가 발생한다면..👀 ??)</strong></p>\n<p>코드의 품질을 테스트하는 방법에는 여러 접근 방식이 있다. (한 가지 정답이 있다고는 생각하지 않는다.)</p>\n<p>오늘은 어떤 접근 방식으로 코드와 서비스의 품질을 검증할 수 있을지에 대한 나만의 방향성을 정리하고 이 과정을 CI 단계에서 E2E 테스트를 선행하도록 구조를 확장하게 된 경험을 최대한 간단히 정리해서 남겨 보려한다.</p>\n<br>\r\n<br>\n<h3 id=\"1-e2e-관점에서-본-코드-품질-테스트\" style=\"position:relative;\"><a href=\"#1-e2e-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"1 e2e 관점에서 본 코드 품질 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. E2E 관점에서 본 코드 품질 테스트</h3>\n<hr>\n<p>작년까지만 해도 각각의 서비스나 유틸리티 함수가 의도한 대로 동작하는지를 검증하는 테스트를 만들기 위해 노력했었다.</p>\n<blockquote>\n<p>예전 포스팅 중 <a href=\"https://blog.jh8459.com/2024-07-15-TIL/\">테스트 커버리지 (Feat. SLASH 21)</a>때만 회고해보아도 단순히 높은 커버리지를 구현해보려 노력한 내 자신을 찾아볼 수 있다. 🥲</p>\n</blockquote>\n<br/>\n<p>하지만 프로젝트가 점차 복잡해지고 다양한 외부 요인(DB, Redis, 외부 API 등)등에 통합되면서 단순히 코드 단위로만 검증하는 방식에 한계를 느끼게 되었다. 로컬 환경에서는 문제가 없이 테스트도 통과한 코드가 실제 환경에서는 DB 연결 문제 혹은 외부 API 응답 오류 등으로 장애를 발생시키는 경우가 발생했기 때문이다.</p>\n<p>단위 테스트 만으로는 각 모듈이 고립되어 제대로 동작하는지를 검증할 뿐 “전체 시스템이 유기적으로 작동하는지”까지는 보장해주지 않는다는 것을 절감하게 됐다.</p>\n<p>이런 경험을 통해 단순히 코드 하나하나가 잘 돌아가는지가 아니라 서비스 전체 플로우가 정상적으로 동작하는지를 검증하는 테스트가 필요하다고 확신하게 되었다.</p>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-04-29-PROJECT/e2e.png\">\n<br><br>\n<p>이런 문제 의식을 갖게되니 자연스럽게 “E2E(End-to-End) 테스트”에 관심을 갖게 되었다.</p>\n<p>단순히 API가 응답하는지만 보는 것이 아니라, 실제로 DB에 데이터를 저장하고 Redis에 캐시를 갱신하며 외부 API와 요청을 주고 받는 전체 흐름을 검증하고자 노력했다. 따라서 가능한 많은 실제 자원(DB, Redis)을 운영 환경과 동일한 환경의 테스트 컨테이너로 구동하여 로컬과 CI 환경에서도 실제 서비스에 근접한 환경으로 테스트하도록 방향을 잡았다.</p>\n<p>결국, 단순히 “코드에 에러는 없는가”를 넘어서 <strong>“전체적으로 문제없이 동작하는가”</strong>를 검증하는 것이 진정한 품질 보장이라는 생각에 이르게 되었다.</p>\n<br>\r\n<br>\n<h3 id=\"2-mocking-vs-실제-자원-사용-기준\" style=\"position:relative;\"><a href=\"#2-mocking-vs-%EC%8B%A4%EC%A0%9C-%EC%9E%90%EC%9B%90-%EC%82%AC%EC%9A%A9-%EA%B8%B0%EC%A4%80\" aria-label=\"2 mocking vs 실제 자원 사용 기준 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Mocking vs 실제 자원 사용 기준</h3>\n<hr>\n<p>테스트 코드를 작성할 때 가장 고민스러웠던 지점 중 하나는 <strong>“어디까지를 실제로 호출할 것인가?”</strong> 였다. 실제 서비스 흐름을 따라가는 E2E 테스트를 지향한다고 아래와 같은 경우는 분명히 발생할 수 있기 때문이다.</p>\n<ul>\n<li>별도의 인증(2fa)이 필요하거나 요금이나 이용 횟수 제한이 있는 API 호출이 필요한 경우.</li>\n<li>예외 상황을 만들어내기 어려운 조건(ex. token 만료 등)이 필요한 경우.</li>\n<li>테스트 속도, 비용, 안정성을 고려해 실제 호출된다면 부작용이 발생할 수 있는 경우.</li>\n</ul>\n<p>따라서 위 기준으로 실제 자원을 사용하는 경우와 목킹(Mocking)을 사용하는 경우를 나누어 실제 호출 여부를 판단했다.</p>\n<br>\r\n<br>\n<p>오늘 예시로 설명할 <a href=\"https://blog.jh8459.com/2024-07-01-PROJECT/\">LOTTERY 🍀</a> 프로젝트의 실제 자원을 사용하는 경우와 목킹(Mocking)을 사용하는 경우는 아래와 같다.</p>\n<br>\n<blockquote>\n<p><strong>[실제 자원을 사용하는 기준]</strong></p>\n<ul>\n<li>DB, Redis는 테스트 컨테이너로 별도로 구동되며 실제 데이터를 읽고 쓰는 테스트를 진행한다.</li>\n<li>Slack Webhook 또는 이메일 발송처럼 사용자 알림과 연관된 기능은 실제 전송은 하지 않지만 전송 직전까지의 흐름을 검증한다.</li>\n<li>API 요청/응답 구조, Slack 명령어 및 액션 흐름과 DB 저장 이후 Slack 전송 등 비즈니스 플로우는 실제 자원들과 연결된 상태로 테스트한다.</li>\n</ul>\n</blockquote>\n<br>\n<blockquote>\n<p><strong>[Mocking이 필요한 기준]</strong></p>\n<ul>\n<li>Slack OAuth, GitHub API와 같이 인증이 필요한 API는 mocking으로 대체하였다.</li>\n<li>예외 상황을 만들어내기 어려운 조건들(ex. Slack API 호출 실패)은 mocking을 통해 시나리오를 구성했다.</li>\n</ul>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"3-테스트-자동화-구축-과정\" style=\"position:relative;\"><a href=\"#3-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%8F%99%ED%99%94-%EA%B5%AC%EC%B6%95-%EA%B3%BC%EC%A0%95\" aria-label=\"3 테스트 자동화 구축 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 테스트 자동화 구축 과정</h3>\n<hr>\n<p>E2E 테스트를 수동으로만 돌려보는 수준이라면 테스트의 신뢰도는 점점 떨어질 수 있다 생각했다. <strong>(개발자가 실수 혹은 악의적인 의도를 갖고 테스트를 실행을 안했다면..? 👀)</strong></p>\n<p>테스트가 항상 유의미하기 위해서는 파이프라인에 자연스럽게 녹아들어야 한다고 생각했고 실제로 그렇게 구성해보려 노력하였다. 내가 설계한 테스트 자동화는 다음과 같은 흐름으로 동작한다.</p>\n<br>\r\n<br>\n<h4 id=\"3-1-테스트용-컨테이너-구성\" style=\"position:relative;\"><a href=\"#3-1-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B5%AC%EC%84%B1\" aria-label=\"3 1 테스트용 컨테이너 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 테스트용 컨테이너 구성</h4>\n<hr>\n<p>E2E 테스트 환경은 실제 서비스와 동일한 구성의 DB(MariaDB), Redis를 담은 <code class=\"language-text\">docker-compose.test.yml</code>로 시작된다. 이 컨테이너들은 테스트 실행 직전에 자동으로 띄워지며 테스트 종료 후 다음 테스트 시 영향을 주지 못하도록 자동으로 정리된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\r\n  <span class=\"token key atrule\">lottery_test_db</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mariadb<span class=\"token punctuation\">:</span>latest\r\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> lottery_test_db\r\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\r\n      <span class=\"token key atrule\">MYSQL_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>DB_PASSWORD<span class=\"token punctuation\">}</span>\r\n      <span class=\"token key atrule\">MYSQL_DATABASE</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>DB_DATABASE<span class=\"token punctuation\">}</span>\r\n      <span class=\"token key atrule\">MYSQL_PASSWORD</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>DB_PASSWORD<span class=\"token punctuation\">}</span>\r\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\r\n      <span class=\"token punctuation\">-</span> $<span class=\"token punctuation\">{</span>DB_PORT<span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span><span class=\"token number\">3306</span>\r\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>default<span class=\"token punctuation\">-</span>authentication<span class=\"token punctuation\">-</span>plugin=mysql_native_password\r\n\r\n  <span class=\"token key atrule\">lottery_test_redis</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis<span class=\"token punctuation\">:</span>latest\r\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> lottery_test_redis\r\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\r\n      <span class=\"token punctuation\">-</span> $<span class=\"token punctuation\">{</span>REDIS_PORT<span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span><span class=\"token number\">6379</span></code></pre></div>\n<br>\n<p>위 컨테이너들은 <code class=\"language-text\">packge.json</code>의 <strong>npm run test</strong> 스크립트 명령으로 E2E 테스트 전 먼저 구동되어 테스트 환경을 먼저 구성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"build\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"nest build\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"start:dev\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"nest start --watch\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"start:prod\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node dist/main\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"test\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm run test:docker:start &amp;&amp; npm run test:e2e || (echo '❌ E2E 테스트 실패' &amp;&amp; exit 1)\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"test:e2e\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"cross-env API_NODE_ENV=test jest --config jest-e2e.json --forceExit\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"test:cov\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm run test:docker:start &amp;&amp; jest --config jest-e2e.json --coverage\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"test:docker:start\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"docker compose --env-file .env.test -f docker-compose.test.yml up -d\"</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<br>\r\n<br>\n<h4 id=\"3-2-github-actions-ci-구성\" style=\"position:relative;\"><a href=\"#3-2-github-actions-ci-%EA%B5%AC%EC%84%B1\" aria-label=\"3 2 github actions ci 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. GitHub Actions CI 구성</h4>\n<hr>\n<p>CI 파이프라인은 다음의 순서를 따릅니다.</p>\n<ol>\n<li><code class=\"language-text\">.env.test</code> 파일을 생성</li>\n<li><code class=\"language-text\">docker-compose.test.yml</code>을 통해 DB/Redis 컨테이너 실행</li>\n<li>E2E 테스트 실행</li>\n<li>테스트 성공 시에만 이후 Build &#x26; Deploy 단계 진행</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> CI &amp; CD\r\n\r\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\r\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>master<span class=\"token punctuation\">]</span>\r\n\r\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\r\n  <span class=\"token key atrule\">test</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> E2E Tests\r\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\r\n\r\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout repository\r\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v4\r\n\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Set up Node.js\r\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v4\r\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\r\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'20.11.0'</span>\r\n\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install dependencies\r\n        <span class=\"token key atrule\">working-directory</span><span class=\"token punctuation\">:</span> ./api\r\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm install\r\n\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Create .env.test\r\n        <span class=\"token key atrule\">working-directory</span><span class=\"token punctuation\">:</span> ./api\r\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\r\n          [ -f ./.env.test ] &amp;&amp; rm ./.env.test\r\n          cat &lt;&lt;EOF > .env.test\r\n          DB_HOST=${{ secrets.TEST_DB_HOST }}\r\n          DB_PORT=${{ secrets.TEST_DB_PORT }}\r\n          DB_USER=${{ secrets.TEST_DB_USER }}\r\n          DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }}\r\n          DB_DATABASE=${{ secrets.TEST_DB_DATABASE }}\r\n          API_SERVER_PORT=${{ secrets.API_SERVER_PORT }}\r\n          ... (생략)\r\n          EOF</span>\r\n\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Start docker<span class=\"token punctuation\">-</span>compose.test.yml (DB + Redis)\r\n        <span class=\"token key atrule\">working-directory</span><span class=\"token punctuation\">:</span> ./api\r\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> docker compose <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>env<span class=\"token punctuation\">-</span>file .env.test <span class=\"token punctuation\">-</span>f docker<span class=\"token punctuation\">-</span>compose.test.yml up <span class=\"token punctuation\">-</span>d\r\n\r\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run Tests\r\n        <span class=\"token key atrule\">working-directory</span><span class=\"token punctuation\">:</span> ./api\r\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm run test\r\n\r\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build Docker Images\r\n    <span class=\"token key atrule\">needs</span><span class=\"token punctuation\">:</span> test\r\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\r\n\r\n    <span class=\"token punctuation\">...</span> (후략)</code></pre></div>\n<br>\r\n<br>\n<p>E2E 테스트가 실패하면 이후 Build 또는 Deploy는 실행되지 못한다. 이를 통해 CI 파이프라인에서 <strong>“코드 품질이 보장된 경우에만 배포”</strong>가 이루어지도록 제어했다.</p>\n<br>\r\n<br>\n<h3 id=\"4-테스트-자동화가-가져온-안정성\" style=\"position:relative;\"><a href=\"#4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%8F%99%ED%99%94%EA%B0%80-%EA%B0%80%EC%A0%B8%EC%98%A8-%EC%95%88%EC%A0%95%EC%84%B1\" aria-label=\"4 테스트 자동화가 가져온 안정성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 테스트 자동화가 가져온 안정성</h3>\n<hr>\n<p>테스트 자동화를 구축하기 전에는 코드가 머지되고 배포되어도 “배포는 잘 됐는데 동작이 안 되면 어쩌지?” 같은 걱정은 해소되지 못하였다. <del>(사실 이 감정은 아직 여전히 느끼고 있다. 🥲)</del> 하지만, CI/CD 파이프라인 안에 E2E 테스트를 녹여낸 이후로는 단순한 배포 성공을 넘어 실제 서비스의 핵심 흐름이 정상 동작하는지까지 사전에 검증할 수 있게 되어 이 불안감은 조금 줄어들지 않았나 싶다.</p>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-04-29-PROJECT/action.png\">\n<center>그래도 불안감은 <del>조금</del> 해소되었다. 💦</center>\r\n<br><br>\n<p>그 외에도 E2E 테스트는 <strong>“어떤 시나리오가 정상 흐름인지”</strong> 코드로 남긴다는 점에서 테스트 코드 자체가 문서 역할을 하게되었다. 이 덕분에 인수인계 혹은 비즈니스 요구사항을 수정할때 커뮤니케이션도 더 명확해졌다.</p>\n<p>특히, 테스트를 염두에 두고 코드를 작성하다 보니 자연스럽게 코딩 스타일과 사고 방식에도 변화가 생겼다.</p>\n<ul>\n<li>클래스 별로 책임을 명확히 나누려 노력한다.</li>\n<li>기능이 많아지면 함수를 쪼개기 위해 노력한다.</li>\n<li><strong>“이건 테스트하기 어렵겠는데?”</strong>라는 감각(?)이 생겼다.</li>\n</ul>\n<br>\n<p>가장 큰 변화로는 코드를 작성하다 보면 이제 자연스럽게 “이렇게 만들면 테스트가 힘들겠는데? 🤔“라는 생각이 먼저 들곤 한다. 테스트가 어려운 구조를 보면 즉시 의심하고 좀 더 테스트가 용이한 형태로 바로 리팩토링하려고 노력하게 되었다.</p>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<p>코드나 서비스의 품질 테스트는 다양한 접근 방식으로 많이 할수록 좋다 생각한다. <del>“E2E 테스트가 유일한 정답이다..!” 취지로 이번 포스팅을 작성한게 아니다..🙏</del></p>\n<p>다만, 주어진 시간안에서 서비스의 품질을 효율적으로 책임지기 위해 고안해낸 주관적인 의견이므로 이 방법이 유일한 정답이다라고 말하고 싶지 않다. 팀의 구성원이 적고 요구사항이 빠르게 변하기 때문에 전체적인 E2E 테스트 위주로 품질을 검증하는 방법을 택하였을 뿐이다.</p>\n<p>테스트 코드들을 작성해나가며 느낀바로는, 어떤 테스트 전략이던지 테스트는 번거롭고 시간이 오래 걸리는게 아닌 품질을 보증하는 가장 빠른 길이라는 것이다.</p>\n<p>미리 실패하고 미리 위험 요인들을 발견하는 것이 가장 중요하다 생각한다.</p>\n<br>\r\n<br>\n<div class=\"gatsby-highlight\" data-language=\"toc\"><pre class=\"language-toc\"><code class=\"language-toc\"></code></pre></div>","frontmatter":{"date":"2025.04.29","title":"E2E 테스트 설계와 테스트 자동화","categories":"Project","author":"JH8459","emoji":"🔥"},"fields":{"slug":"/2025-04-29-PROJECT/"}},"prev":{"id":"90e78069-3c60-5f51-88c9-9222da448289","html":"<p><img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-06-27-RETROSPECT/certification.png\" alt=\"certification\"></p>\n<br>\n<h2 id=\"sqld-취득-후기\" style=\"position:relative;\"><a href=\"#sqld-%EC%B7%A8%EB%93%9D-%ED%9B%84%EA%B8%B0\" aria-label=\"sqld 취득 후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQLD 취득 후기</h2>\n<h3 id=\"1-취득-계기\" style=\"position:relative;\"><a href=\"#1-%EC%B7%A8%EB%93%9D-%EA%B3%84%EA%B8%B0\" aria-label=\"1 취득 계기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 취득 계기</h3>\n<hr>\n<p>생각해보면 개발을 하면서 수시로 SQL을 접했지만 정작 SQL을 제대로 학습해본 적은 없었다. 🤔</p>\n<p>백엔드 개발자로써 주로 ORM을 사용하는 환경에 익숙하다 보니 실제 쿼리를 작성할 일도 드물었고, DBMS에서 데이터를 조회하기 위해 쿼리문이 필요할 때도 AI에 의존해서 해결하는 등 어깨넘어(?)로 SQL에 익숙해져있을 뿐이지 정식으로 공부해본적은 없었다.</p>\n<p>SQL을 깊게까진 아니어도 “기본기라도 잡아봐야겠다.” 라는 생각이 들었고,  마침 <strong>SQLD</strong>라는 국가공인 자격증이 있다는 걸 알게 되었다.</p>\n<p>이왕 공부하는 김에 자격증 취득이라는 명확한 목표를 세우면 동기 부여도 되겠다 싶어 도전하게 되었다.</p>\n<br>\r\n<br>\n<h3 id=\"2-취득-과정\" style=\"position:relative;\"><a href=\"#2-%EC%B7%A8%EB%93%9D-%EA%B3%BC%EC%A0%95\" aria-label=\"2 취득 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 취득 과정</h3>\n<hr>\n<p>사실 이 자격증은 이른바 <strong>“노랭이”</strong>라고 불리는 문제집을 얼마나 반복해서 풀어야 하는지에 달렸다. <strong>(2025년 SQLD 57회 기준)</strong></p>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-06-27-RETROSPECT/book.jpg\">\n<center>SQL 자격검정 실전문제 문제집을 최소 2번 이상은 반복 풀이하자 ✌️</center>\r\n<br><br>\n<p>나는 자격증 취득을 위해 <strong>총 3회독</strong>을 했고 하루 평균 1~2시간씩 총 공부 기간은 약 <strong>2주 정도</strong>였다.</p>\n<blockquote>\n<p>참고로 나는 보편적인 SQL은 이미 사용할 줄 알고 어느정도 기초 지식은 있다 생각한다.</p>\n</blockquote>\n<br>\n<p>2회독까진 문제 유형을 파악하려 노력했고 전반적인 자격 시험에 대한 구조를 익히는 데 집중했다. 특히, 처음 접하는 용어나 생소한 개념들은 체크해둔 뒤 따로 찾아봤다.</p>\n<blockquote>\n<p>정규화나 조인, 뷰 같은 보편적인 개념들은 이미 실무를 하며 몇번 사용한 경험이 있었기에 과감히 개념 학습은 하지 않고 문제 풀이를 통해서 감을 잡아갔다. (기초 지식이 없다면 개념 학습을 위해 반드시 시간을 할애 해야한다.)</p>\n</blockquote>\n<br>\n<p>마지막 3회독땐 오답 중심으로 복습을 했다. 틀린 문제와 헷갈린 개념 위주로 다시 풀되, 반복 풀이로도 잘 이해가 안가는 개념들은 배제했다. <del>(60점만 넘기자..😂)</del></p>\n<blockquote>\n<p>주의할 점으로 과락<strong>(과목별 정답률 40% 이상)</strong>이 있기 때문에 너무 많은 문제 유형을 배제하는건 옳지 않다.</p>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"3-취득-후기\" style=\"position:relative;\"><a href=\"#3-%EC%B7%A8%EB%93%9D-%ED%9B%84%EA%B8%B0\" aria-label=\"3 취득 후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 취득 후기</h3>\n<hr>\n<p>합격 기준은 60점인데, 다행히도 68점으로 합격을하였다. 😀</p>\n<br>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-06-27-RETROSPECT/score.png\">\n<center>가채점 결과는 최종 결과 발표 1주일 전 선 공개된다.</center>\r\n<br><br>\n<p>생각보다 시험장 입실 후 대기시간이 길기 때문에 오답노트는 필히 챙겨가자. 또한, 신분증과 <del>수험표</del> 또한 반드시 챙겨가자. (수험번호는 감독관님께 문의하면 알려주신다.)</p>\n<p>시험은 모두 오프라인으로 이뤄기에 OMR카드 작성을 직접해야한다. 따라서 마킹 실수를 고려하여 시간 분배를 잘 해야한다. 너무 오랫만에 컴퓨터 싸인펜을 만져봐서 그런지 마킹을 실수했다.</p>\n<p>다른 회차 후기들은 개정판 노랭이 속 문제와 단어까지 똑같이 출제되었다는 후기가 많았는데, 내가 응시한 57회에서는 처음 보는 유형의 문제도 나와서 오히려 당황했다. (갈수록 새로운 유형의 문제들이 출제되는게 아닐까 싶다.)</p>\n<blockquote>\n<p><code class=\"language-text\">WHERE</code> 절에서 사용할 정규표현식 관련한 문제로 기억하는데, 노랭이 3회독을 하면서 전혀 본 적 없는 유형이었다.</p>\n</blockquote>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<p>25년 상반기에 자격증 취득을 2개를 계획했는데 다행히 마침표를 잘 찍은거 같다.</p>\n<p>SQLD는 난이도가 크게 어렵지 않은 자격증이라 생각되기에 시간적 여유만 있다면 그 누구라도 취득할 수 있다 생각한다. 이 글이 시험을 준비하시는 분들께 조금이라도 도움이 되시길 빌며, 모두 합격을 기원한다.</p>\n<br>\r\n<br>\n<div class=\"gatsby-highlight\" data-language=\"toc\"><pre class=\"language-toc\"><code class=\"language-toc\"></code></pre></div>","frontmatter":{"date":"2025.06.27","title":"SQLD 취득 후기","categories":"Retrospect","author":"JH8459","emoji":"🤔"},"fields":{"slug":"/2025-06-27-RETROSPECT/"}},"site":{"siteMetadata":{"siteUrl":"https://blog.jh8459.com","comments":{"utterances":{"repo":"JH8459/JH8459.github.io"}}}}},"pageContext":{"slug":"/2025-05-20-TIL/","nextSlug":"/2025-04-29-PROJECT/","prevSlug":"/2025-06-27-RETROSPECT/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"],"slicesMap":{}}