{"componentChunkName":"component---src-templates-blog-template-js","path":"/2025-11-16-WEB/","result":{"data":{"cur":{"id":"cbd2537d-bbfa-5389-984c-f9d90d8d941b","html":"<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-11-16/web/thumbnail.png\">\n<h2 id=\"-overview\" style=\"position:relative;\"><a href=\"#-overview\" aria-label=\" overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📚 Overview</h2>\n<p><code class=\"language-text\">structuredClone()</code>은 값 전체를 깊은 복사(Deep Copy) 해주는 Web Platform API다. <code class=\"language-text\">JSON.parse(JSON.stringify(...))</code> 나 <code class=\"language-text\">lodash.cloneDeep</code> 같은 우회 방법 없이, 웹 표준 API로 공식 지원하는 딥 클론 도구라고 볼 수 있다.</p>\n<p>이번 글에서는 아래 내용을 다뤄 볼 예정이다.</p>\n<ul>\n<li><code class=\"language-text\">structuredClone()</code>은 어떤 표준에 속하는가?</li>\n<li>기본 문법과 동작 방식</li>\n<li><code class=\"language-text\">JSON.stringify</code>과의 비교</li>\n<li>실무에서 활용 사례</li>\n</ul>\n<br>\r\n<br>\n<h3 id=\"1-structuredclone은-어디-표준에-속할까\" style=\"position:relative;\"><a href=\"#1-structuredclone%EC%9D%80-%EC%96%B4%EB%94%94-%ED%91%9C%EC%A4%80%EC%97%90-%EC%86%8D%ED%95%A0%EA%B9%8C\" aria-label=\"1 structuredclone은 어디 표준에 속할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. structuredClone()은 어디 표준에 속할까?</h3>\n<hr>\n<p>먼저 짚고 갈 내용은 <code class=\"language-text\">structuredClone()</code>은 ES 표준(ECMAScript Language Specification)에 정의된 문법이 아니다.</p>\n<p><code class=\"language-text\">structuredClone()</code>은 <code class=\"language-text\">let</code>, <code class=\"language-text\">class</code>, <code class=\"language-text\">Promise</code>, <code class=\"language-text\">Array.prototype.map</code>처럼 ECMAScript가 정의한 “언어 자체의 기능”이 아니다.</p>\n<p>오히려 <code class=\"language-text\">fetch</code>처럼 브라우저(Web Platform)가 환경 차원에서 제공하는 API에 더 가깝다. 즉, JavaScript 문법에 포함된 기능이 아니라 브라우저나 Node.js가 구현한 <strong>Web API</strong>를 통해 사용할 수 있는 기능이다.</p>\n<img src=\"https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-11-16/web/console.png\">\n<center>따라서 이런 콘솔에서도 간편하게 사용이 가능하다.</center>\r\n<br><br>\n<p>MDN에서도 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\"><code class=\"language-text\">Window: structuredClone() method</code></a>와 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/structuredClone\"><code class=\"language-text\">WorkerGlobalScope: structuredClone() method</code></a>로 각각 문서화되어 있으며, 해당 내용은 결국 WHATWG의 <a href=\"https://html.spec.whatwg.org/multipage/structured-data.html#structuredserialize\"><code class=\"language-text\">HTML Standard</code></a>에서 정의한 구조화 복제 알고리즘을 기반으로 한다.</p>\n<blockquote>\n<p>💡 <code class=\"language-text\">structuredClone()</code>이 속한 스펙은 <strong>WHATWG HTML Standard</strong>다.<br>\nWHATWG(웹 하이퍼텍스트 애플리케이션 기술 워킹 그룹)는 HTML, DOM, Fetch 같은 <strong>웹 플랫폼 핵심 표준을 정의하는 단체</strong>로, 브라우저들이 공통으로 구현하는 “실제 웹 표준”을 만든다.</p>\n<p><code class=\"language-text\">structuredClone()</code> 역시 이 HTML Standard에 포함된 <strong>Structured Clone Algorithm</strong>을 기반으로 제공되는 Web API다.</p>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"2-기본-문법\" style=\"position:relative;\"><a href=\"#2-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95\" aria-label=\"2 기본 문법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 기본 문법</h3>\n<hr>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\">https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone</a></p>\n</blockquote>\n<ul>\n<li>value: 복제할 값. structured-cloneable 타입이라면 대부분 가능하다.</li>\n<li>options(transfer): 복제 대신 “소유권을 넘길” 객체 리스트 (ArrayBuffer 등 Transferable 타입).</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 기본 형태</span>\r\n<span class=\"token function\">structuredClone</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// Transferable objects 옵션을 함께 넘길 때</span>\r\n<span class=\"token function\">structuredClone</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token literal-property property\">transfer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token comment\">/* ArrayBuffer, ImageBitmap ... */</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">structuredClone()</code>의 반환 값은 항상 원본과 분리된 깊은 복사(Deep Copy) 이다.</p>\n<br>\n<blockquote>\n<p>💡 Transferable objects 란?</p>\n<p>Transferable objects는 말 그대로 “복사하는 대신 소유권을 이동시킬 수 있는 값” 을 의미한다.</p>\n<p>예를 들어 ArrayBuffer 같은 대용량 버퍼를 생각해보면, 복사하려면 메모리를 또 만들어야 하고 시간도 오래 걸리게 된다.</p>\n<p>그래서 브라우저는 “복사하지 말고 그냥 소유권을 다른 곳으로 옮겨버리는 방식”을 지원한다. 즉, Transferable로 지정하면 복사하지 않아도 되므로 성능상 이점이 있게된다.</p>\n<p>단, 원래 객체를 참조하던 곳에서는 이 값을 더 이상 사용할 수 없다.</p>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"3-순환-참조가-있는-객체도-안전하게-복사\" style=\"position:relative;\"><a href=\"#3-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0%EA%B0%80-%EC%9E%88%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%8F%84-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%B3%B5%EC%82%AC\" aria-label=\"3 순환 참조가 있는 객체도 안전하게 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 순환 참조가 있는 객체도 안전하게 복사</h3>\n<hr>\n<p>structured clone 알고리즘은 내부에서 참조를 기록하며 순환 구조를 처리한다.</p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> original <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'structured clone'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\noriginal<span class=\"token punctuation\">.</span>self <span class=\"token operator\">=</span> original<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 순환 참조</span>\r\n\r\n<span class=\"token keyword\">const</span> cloned <span class=\"token operator\">=</span> <span class=\"token function\">structuredClone</span><span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cloned <span class=\"token operator\">===</span> original<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// false (다른 객체)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cloned<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// 'structured clone'</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cloned<span class=\"token punctuation\">.</span>self <span class=\"token operator\">===</span> cloned<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// true (순환 구조 유지)</span></code></pre></div>\n<p>이 부분이 <code class=\"language-text\">JSON.parse(JSON.stringify(obj))</code>와 가장 큰 차이 중 하나다.</p>\n<br>\r\n<br>\n<h3 id=\"4-jsonparsejsonstringify와-비교\" style=\"position:relative;\"><a href=\"#4-jsonparsejsonstringify%EC%99%80-%EB%B9%84%EA%B5%90\" aria-label=\"4 jsonparsejsonstringify와 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. JSON.parse(JSON.stringify(…))와 비교</h3>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> deepCopied <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 문법의 장점은 단순함이지만, 다음과 같은 문제를 가진다.</p>\n<ul>\n<li>순환 참조가 있으면 <code class=\"language-text\">JSON.stringify()</code> 단계에서 예외 발생</li>\n<li><code class=\"language-text\">Map</code>, <code class=\"language-text\">Set</code>, <code class=\"language-text\">Date</code>, <code class=\"language-text\">RegExp</code>, <code class=\"language-text\">ArrayBuffer</code> 타입은 깨지거나 문자열화</li>\n<li>함수는 제거됨</li>\n</ul>\n<br>\n<p>하지만 <code class=\"language-text\">structuredClone()</code>은 위에 열거한 단점들이 상당 부분 보완된다.</p>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th>JSON 기반 딥 클론(<code class=\"language-text\">JSON.stringify</code>)</th>\n<th>structuredClone()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>순환 참조</td>\n<td>❌ 순환 구조 발견 시 예외 발생</td>\n<td>✅ 순환 참조 그대로 복제 가능</td>\n</tr>\n<tr>\n<td>Map / Set / Date / RegExp / ArrayBuffer 등</td>\n<td>❌ 대부분 문자열화되거나 일반 객체로 변형</td>\n<td>✅ 스펙에 정의된 방식으로 올바르게 복제됨</td>\n</tr>\n<tr>\n<td>함수(Function)</td>\n<td>⭕ 오류 없이 포함되지만 <strong>그냥 제거됨</strong></td>\n<td>❌ 포함 시 <code class=\"language-text\">DataCloneError</code> 예외 발생</td>\n</tr>\n<tr>\n<td>타입 보존</td>\n<td>❌ 단순 객체/배열만 제대로 보존</td>\n<td>✅ Map, Set 등 다양한 Web/JS 타입 보존</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 함수(Function)는 복제할 수 없다</p>\n<p><code class=\"language-text\">structuredClone()</code>은 함수, 클래스 메서드와 같은  <strong>실행 가능한 코드(executable code)</strong> 는 복제하지 못한다. 이런 값이 포함된 객체를 전달하면 조용히 무시되는 것이 아니라 <strong><code class=\"language-text\">DataCloneError</code> (DOMException)</strong> 를 바로 던진다.</p>\n</blockquote>\n<br>\r\n<br>\n<h3 id=\"5-실무에서-언제-쓰면-좋을까\" style=\"position:relative;\"><a href=\"#5-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%96%B8%EC%A0%9C-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"5 실무에서 언제 쓰면 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 실무에서 언제 쓰면 좋을까?</h3>\n<hr>\n<p>API 요청을 처리하다 보면 원본 요청 값(req.body)을 그대로 남겨두고, 별도로 가공한 객체를 만들어야 하는 경우가 많다.</p>\n<p>예를 들어 로깅, 검증, 내부 시스템 전달용 DTO 등을 만들 때 다음과 같은 형태로 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> original <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// 원본은 그대로 유지</span>\r\n<span class=\"token keyword\">const</span> payload <span class=\"token operator\">=</span> <span class=\"token function\">structuredClone</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 가공용 깊은 복사 객체</span>\r\n\r\npayload<span class=\"token punctuation\">.</span>flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token function\">process</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 하면 원본 값을 오염시키지 않고 깨끗한 복제본을 기반으로 후처리를 안전하게 수행할 수 있다.</p>\n<br>\r\n<br>\n<h2 id=\"-understanding\" style=\"position:relative;\"><a href=\"#-understanding\" aria-label=\" understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Understanding</h2>\n<p><code class=\"language-text\">structuredClone()</code>은 객체를 깊게 복사하기 위해 Web Platform이 제공하는 <strong>표준 깊은 복사 API</strong>임을 알게되었다.</p>\n<p>기존에 사용되던 <code class=\"language-text\">JSON.parse(JSON.stringify())</code> 방식이 가진 한계(타입 손실, 순환 참조 예외 등)를 해결하고, 라이브러리 없이도 브라우저와 Node.js에서 동일한 방식으로 <strong>표준화된 Deep Copy</strong>를 수행할 수 있다는 점이 가장 큰 장점으로 느껴진다.</p>","excerpt":"📚 Overview 은 값 전체를 깊은 복사(Deep Copy) 해주는 Web Platform API다.  나  같은 우회 방법 없이, 웹 표준 API로 공식 지원하는 딥 클론 도구라고 볼 수 있다. 이번 글에서는 아래 내용을 다뤄 볼 예정이다. 은 어떤 표준에 속하는가? 기본 문법과 동작 방식 과의 비교 실무에서 활용 사례 1. structuredClone()은 어디 표준에 속할까? 먼저 짚고 갈 내용은 은 ES 표준(ECMAScript Language Specification)에 정의된 문법이 아니다. 은 , , , 처럼 ECMAScript가 정의한 “언어 자체의 기능”이 아니다. 오히려 처럼 브라우저(Web Platform)가 환경 차원에서 제공하는 API에 더 가깝다. 즉, JavaScript 문법에 포함된 기능이 아니라 브라우저나 Node.js가 구현한 Web API를 통해 사용할 수 있는 기능이다. MDN에서도 와 로 각각 문서화되어 있으며, 해당 내용은 결국 WHATW…","timeToRead":3,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#-overview\">📚 Overview</a></p>\n<ul>\n<li><a href=\"#1-structuredclone%EC%9D%80-%EC%96%B4%EB%94%94-%ED%91%9C%EC%A4%80%EC%97%90-%EC%86%8D%ED%95%A0%EA%B9%8C\">1. structuredClone()은 어디 표준에 속할까?</a></li>\n<li><a href=\"#2-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95\">2. 기본 문법</a></li>\n<li><a href=\"#3-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0%EA%B0%80-%EC%9E%88%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%8F%84-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%B3%B5%EC%82%AC\">3. 순환 참조가 있는 객체도 안전하게 복사</a></li>\n<li><a href=\"#4-jsonparsejsonstringify%EC%99%80-%EB%B9%84%EA%B5%90\">4. JSON.parse(JSON.stringify(…))와 비교</a></li>\n<li><a href=\"#5-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%96%B8%EC%A0%9C-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">5. 실무에서 언제 쓰면 좋을까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-understanding\">🤔 Understanding</a></p>\n</li>\n</ul>","frontmatter":{"date":"2025.11.16","title":"structuredClone() – Web Platform이 제공하는 표준 딥 클론","categories":"Web","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-11-16-WEB/"}},"next":{"id":"6d5fecbb-ee9a-5441-9b39-04ea5ed6eb65","frontmatter":{"date":"2025.11.08","title":"Object.groupBy / Map.groupBy (ES2024)","categories":"JavaScript","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-11-08-JAVASCRIPT/"}},"prev":{"id":"3c1776a0-e6ad-59ef-9dc6-d85460618002","frontmatter":{"date":"2025.12.01","title":"MikroORM v6.6 – 무엇이 달라졌나?","categories":"Backend","author":"JH8459","emoji":"📚"},"fields":{"slug":"/2025-12-01-BACKEND/"}},"site":{"siteMetadata":{"siteUrl":"https://blog.jh8459.com","comments":{"giscus":{"repo":"JH8459/JH8459.github.io","repoId":"R_kgDOI03HgA","category":"Comments","categoryId":"DIC_kwDOI03HgM4CtuXL"}}}}},"pageContext":{"slug":"/2025-11-16-WEB/","nextSlug":"/2025-11-08-JAVASCRIPT/","prevSlug":"/2025-12-01-BACKEND/"}},"staticQueryHashes":["1073350324","2009502679","2938748437","962130685"],"slicesMap":{}}